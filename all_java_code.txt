package main;

import models.Car;
import models.HumanBeing;
import models.Mood;
import models.WeaponType;
import utility.*;
import utility.Console;

import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

public class ClientMain {
    private static Integer userId = null;
    private static List<String> users = new ArrayList<>();

    public static void main(String[] args) {
        String host = "localhost";
        int port = 5000;
        Console console = new StandardConsole();

        try (Socket socket = new Socket(host, port);
             ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
             ObjectInputStream input = new ObjectInputStream(socket.getInputStream())) {

            console.println("Подключено к серверу: " + host + ":" + port);

            while (true) {
                console.println("Введите команду: ");
                String command = console.read().trim();
                Object argument = null;

                if (command.equals("exit")) {
                    output.writeObject(command);
                    output.writeObject(null);
                    output.writeObject(userId);
                    break;
                }

                String[] parts = command.split("\\s+", 2);
                String commandName = parts[0].toLowerCase();

                if (commandName.equals("delete_user")) {
                    if (userId == null) {
                        console.println("Ошибка: необходимо авторизоваться");
                        continue;
                    }
                    output.writeObject("get_users");
                    output.writeObject(null);
                    output.writeObject(userId);
                    output.flush();

                    ExecutionResponse response = (ExecutionResponse) input.readObject();
                    if (!response.isSuccess()) {
                        console.println("Ошибка при получении списка пользователей: " + response.getMessage());
                        continue;
                    }

                    String[] usersList = response.getMessage().split("\n");
                    users.clear();
                    for (String user : usersList) {
                        if (!user.trim().isEmpty()) {
                            users.add(user.trim());
                        }
                    }

                    if (users.isEmpty()) {
                        console.println("Список пользователей пуст");
                        continue;
                    }

                    console.println("Список пользователей:");
                    for (int i = 0; i < users.size(); i++) {
                        console.println((i + 1) + ". " + users.get(i));
                    }

                    console.println("Введите номер пользователя для удаления:");
                    String inputStr = console.read().trim();
                    int userNumber;
                    try {
                        userNumber = Integer.parseInt(inputStr);
                        if (userNumber < 1 || userNumber > users.size()) {
                            console.println("Ошибка: неверный номер пользователя");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректный номер");
                        continue;
                    }

                    String usernameToDelete = users.get(userNumber - 1);
                    console.println("Вы уверены, что хотите удалить пользователя " + usernameToDelete + "? (да/нет)");
                    String confirmation = console.read().trim().toLowerCase();
                    if (!confirmation.equals("да")) {
                        console.println("Удаление отменено");
                        continue;
                    }

                    users.remove(userNumber - 1);
                    console.println("Пользователь " + usernameToDelete + " успешно удален");
                    continue;
                }

                if (commandName.equals("register") || commandName.equals("login")) {
                    console.println("Введите имя пользователя (не пустое):");
                    String username = console.read().trim();
                    if (username.isEmpty()) {
                        console.println("Ошибка: имя пользователя не может быть пустым");
                        continue;
                    }

                    console.println("Введите пароль (не пустой):");
                    String password = console.read().trim();
                    if (password.isEmpty()) {
                        console.println("Ошибка: пароль не может быть пустым");
                        continue;
                    }

                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(username);
                    humanBeing.setCar(new Car(password));
                    argument = humanBeing;
                } else if (commandName.equals("execute_script")) {
                    console.println("Введите путь к файлу скрипта:");
                    String scriptPath = console.read().trim();
                    if (scriptPath.isEmpty()) {
                        console.println("Ошибка: путь к файлу не может быть пустым");
                        continue;
                    }
                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(scriptPath);
                    argument = humanBeing;
                } else if (commandName.equals("removebyid")) {
                    console.println("Введите id элемента для удаления (целое положительное число):");
                    String idInput = console.read().trim();
                    Long id;
                    try {
                        id = Long.parseLong(idInput);
                        if (id <= 0) {
                            console.println("Ошибка: id должен быть положительным числом");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректное целое число для id");
                        continue;
                    }
                    argument = id;
                } else {
                    if (userId == null) {
                        console.println("Ошибка: необходимо войти в систему (login) или зарегистрироваться (register)");
                        continue;
                    }

                    if (commandName.equals("add")) {
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("update")) {
                        console.println("Введите id элемента для обновления (целое положительное число):");
                        String idInput = console.read().trim();
                        Long id;
                        try {
                            id = Long.parseLong(idInput);
                            if (id <= 0) {
                                console.println("Ошибка: id должен быть положительным числом");
                                continue;
                            }
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число для id");
                            continue;
                        }
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            humanBeing.setId(id);
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("filter_starts_with_name")) {
                        console.println("Введите имя (не пустое):");
                        String name = console.read().trim();
                        if (name.isEmpty()) {
                            console.println("Ошибка: имя не может быть пустым");
                            continue;
                        }
                        HumanBeing humanBeing = new HumanBeing();
                        humanBeing.setName(name);
                        argument = humanBeing;
                    } else if (commandName.equals("count_less_than_impact_speed")) {
                        console.println("Введите impactSpeed (целое число):");
                        String impactSpeedInput = console.read().trim();
                        try {
                            long impactSpeed = Long.parseLong(impactSpeedInput);
                            HumanBeing humanBeing = new HumanBeing();
                            humanBeing.setImpactSpeed(impactSpeed);
                            argument = humanBeing;
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число");
                            continue;
                        }
                    }
                }

                output.writeObject(commandName);
                output.writeObject(argument);
                output.writeObject(userId);
                output.flush();

                ExecutionResponse response = (ExecutionResponse) input.readObject();
                console.println("Ответ сервера: " + response.getMessage());

                if (commandName.equals("execute_script")) {
                    if (response.isSuccess()) {
                        console.println("Результат выполнения скрипта:");
                        String message = response.getMessage();
                        if (message != null && !message.isEmpty()) {
                            String[] lines = message.split("\\r?\\n");
                            for (String line : lines) {
                                console.println(line);
                            }
                        } else {
                            console.println("Пустой результат от сервера");
                        }
                    } else {
                        console.println("Ошибка выполнения скрипта: " + response.getMessage());
                    }
                }

                if ((commandName.equals("login") || commandName.equals("register")) && response.isSuccess()) {
                    try {
                        userId = Integer.parseInt(response.getMessage());
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: некорректный userId от сервера");
                    }
                }
            }
        } catch (IOException | ClassNotFoundException e) {
            console.println("Ошибка клиента: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
package main.gui;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.util.Locale;
import java.util.ResourceBundle;

public class MainApp extends Application {
    private static Locale currentLocale = new Locale("ru", "RU");

    public static void setLocale(Locale locale) {
        currentLocale = locale;
    }

    public static Locale getLocale() {
        return currentLocale;
    }

    public static ResourceBundle getBundle() {
        return ResourceBundle.getBundle("main.gui.locale.messages", currentLocale);
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        ResourceBundle bundle = getBundle();
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/main/gui/views/auth.fxml"), bundle);
        Scene scene = new Scene(loader.load());
        primaryStage.setTitle(bundle.getString("window.auth"));
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
package main.gui.controllers;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.MainApp;

import java.util.Locale;

public class AuthController {
    @FXML private TextField usernameField;
    @FXML private PasswordField passwordField;
    @FXML private Button loginButton;
    @FXML private Button registerButton;
    @FXML private ComboBox<String> languageBox;
    @FXML private Label messageLabel;

    // Пример "базы пользователей" (замени на запрос к серверу)
    private static final String TEST_USERNAME = "user";
    private static final String TEST_PASSWORD = "1234";

    @FXML
    private void initialize() {
        languageBox.getItems().setAll("Русский", "Македонский", "Latviešu", "Español (Colombia)");
        // выбор текущей локали...
        Locale current = MainApp.getLocale();
        int idx = 0;
        if (current.getLanguage().equals("ru")) idx = 0;
        else if (current.getLanguage().equals("mk")) idx = 1;
        else if (current.getLanguage().equals("lv")) idx = 2;
        else if (current.getLanguage().equals("es")) idx = 3;
        languageBox.getSelectionModel().select(idx);

        languageBox.setOnAction(event -> {
            switch (languageBox.getValue()) {
                case "Русский":
                    MainApp.setLocale(new Locale("ru", "RU"));
                    break;
                case "Македонский":
                    MainApp.setLocale(new Locale("mk", "MK"));
                    break;
                case "Latviešu":
                    MainApp.setLocale(new Locale("lv", "LV"));
                    break;
                case "Español (Colombia)":
                    MainApp.setLocale(new Locale("es", "CO"));
                    break;
            }
            java.util.ResourceBundle.clearCache();
            reload();
        });
    }

    private void reload() {
        Stage stage = (Stage) usernameField.getScene().getWindow();
        stage.close();
        try {
            new MainApp().start(new Stage());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @FXML
    private void handleLogin(ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.empty"));
            return;
        }
        // Пример: проверка с тестовыми данными (замени на обращение к серверу)
        if (username.equals(TEST_USERNAME) && password.equals(TEST_PASSWORD)) {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.success"));
            // TODO: переход на главное окно
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.fail"));
        }
    }

    @FXML
    private void handleRegister(ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.empty"));
            return;
        }
        // Пример: если логин совпадает с тестовым — ошибка
        if (username.equals(TEST_USERNAME)) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.fail"));
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.success"));
            // TODO: добавить пользователя в базу или отправить на сервер
        }
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;

public class MainController {
    @FXML private Label userLabel;
    @FXML private TableView<?> tableView; // замените ? на ваш класс-модель
    @FXML private Canvas canvas;

    @FXML
    private void initialize() {
        userLabel.setText("User: ..."); // тут отобразите имя пользователя из сессии
        // Настройка TableView, загрузка данных с сервера
    }

    @FXML
    private void handleCanvasClick(MouseEvent event) {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        // TODO: обработка клика, выделение объекта, вывод информации
    }

    // Добавьте методы для фильтрации, сортировки, обновления таблицы, работы с графикой и т.д.
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return "HumanBeing{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", coordinates=" + coordinates +
                ", creationDate=" + creationDate +
                ", realHero=" + realHero +
                ", hasToothpick=" + hasToothpick +
                ", impactSpeed=" + impactSpeed +
                ", weaponType=" + weaponType +
                ", mood=" + mood +
                ", car=" + car +
                ", userId=" + userId +
                '}';
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;

public class ExecutionResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private final boolean success;
    private final String message;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        humanBeing.setCoordinates(new Coordinates(x, y));

        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood mood = Mood.valueOf(moodInput.toUpperCase());
                humanBeing.setMood(mood.toString());
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;

public class Request implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package commands;

import models.HumanBeing;
import utility.ExecutionResponse;
import managers.CollectionManager;

public class Add extends Command {
    private final CollectionManager collectionManager;

    public Add(CollectionManager collectionManager) {
        super("add", "добавить новый элемент в коллекцию");
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null) {
            return new ExecutionResponse(false, "Ошибка: объект не может быть null");
        }
        humanBeing.setUserId(userId);
        boolean success = collectionManager.add(humanBeing, userId);
        if (success) {
            return new ExecutionResponse(true, "Элемент успешно добавлен с id: " + humanBeing.getId());
        } else {
            return new ExecutionResponse(false, "Не удалось добавить элемент");
        }
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Clear extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Clear(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("clear", "очистить коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: clear, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        boolean success = collectionManager.clear(userId);
        if (success) {
            return new ExecutionResponse(true, "Коллекция успешно очищена для пользователя с ID " + userId);
        } else {
            return new ExecutionResponse(false, "Ошибка при очистке коллекции");
        }
    }
}
package commands;

import models.HumanBeing;
import utility.ExecutionResponse;

public abstract class Command {
    protected String name;
    protected String description;

    public Command(String name, String description) {
        this.name = name;
        this.description = description;
    }

    public abstract ExecutionResponse execute(HumanBeing argument, Integer userId);

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class CountLessThanImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public CountLessThanImpactSpeed(Console console, CollectionManager collectionManager) {
        super("count_less_than_impact_speed", "вывести количество элементов, значение поля impactSpeed которых меньше заданного");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: count_less_than_impact_speed, userId: " + userId);
        if (argument == null || argument.getImpactSpeed() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать значение impactSpeed");
        }

        long threshold = argument.getImpactSpeed();
        long count = collectionManager.getCollection().stream()
                .filter(h -> h.getUserId().equals(userId))
                .filter(h -> h.getImpactSpeed() < threshold)
                .count();

        return new ExecutionResponse(true, "Количество элементов с impactSpeed меньше " + threshold + ": " + count);
    }
}
package commands;

import models.HumanBeing;
import models.Coordinates;
import models.Car;
import models.WeaponType;
import models.Mood;
import utility.Console;
import utility.ExecutionResponse;
import managers.CommandManager;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;

public class ExecuteScript extends Command {
    private final Console console;
    private final CommandManager commandManager;
    private final Set<String> executedFiles = new HashSet<>();
    private final List<String> inputLines = new ArrayList<>();

    public ExecuteScript(Console console, CommandManager commandManager) {
        super("execute_script", "исполнить скрипт из файла");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || humanBeing.getName() == null || humanBeing.getName().trim().isEmpty()) {
            return new ExecutionResponse(false, "Требуется путь к файлу скрипта");
        }

        String scriptPath = humanBeing.getName().trim();

        try {
            String absolutePath = Paths.get(scriptPath).toAbsolutePath().toString();

            if (executedFiles.contains(absolutePath)) {
                return new ExecutionResponse(false, "Обнаружена рекурсия: файл " + scriptPath + " уже выполняется");
            }

            executedFiles.add(absolutePath);
            StringBuilder scriptOutput = new StringBuilder();

            try (BufferedReader reader = new BufferedReader(new FileReader(absolutePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith("#")) continue;

                    String[] parts = line.split("\\s+", 2);
                    String commandName = parts[0].toLowerCase();
                    HumanBeing commandHumanBeing = new HumanBeing();

                    if (commandName.equals("execute_script")) {
                        commandHumanBeing.setName(parts.length > 1 ? parts[1] : "");
                    } else if (commandName.equals("add") || commandName.equals("update")) {
                        // Читаем следующие 9 строк для команды add/update
                        inputLines.clear();
                        for (int i = 0; i < 9; i++) {
                            String nextLine = reader.readLine();
                            if (nextLine == null) {
                                return new ExecutionResponse(false, "Неожиданный конец файла при чтении параметров команды " + commandName);
                            }
                            nextLine = nextLine.trim();
                            if (nextLine.isEmpty()) {
                                i--; // Пропускаем пустые строки
                                continue;
                            }
                            inputLines.add(nextLine);
                        }
                        // Устанавливаем параметры в объект HumanBeing в правильном порядке
                        if (inputLines.size() >= 1) commandHumanBeing.setName(inputLines.get(0));
                        if (inputLines.size() >= 3) {
                            try {
                                double x = Double.parseDouble(inputLines.get(1));
                                float y = Float.parseFloat(inputLines.get(2));
                                commandHumanBeing.setCoordinates(new Coordinates(x, y));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении координат: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 4) commandHumanBeing.setRealHero(Boolean.parseBoolean(inputLines.get(3)));
                        if (inputLines.size() >= 5) commandHumanBeing.setHasToothpick(Boolean.parseBoolean(inputLines.get(4)));
                        if (inputLines.size() >= 6) {
                            try {
                                commandHumanBeing.setImpactSpeed(Long.parseLong(inputLines.get(5)));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении impactSpeed: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 7) {
                            try {
                                commandHumanBeing.setWeaponType(WeaponType.valueOf(inputLines.get(6)));
                            } catch (IllegalArgumentException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении weaponType: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 8) commandHumanBeing.setMood(inputLines.get(7));
                        if (inputLines.size() >= 9) {
                            String carName = inputLines.get(8);
                            commandHumanBeing.setCar(new Car(carName));
                        }
                        // Устанавливаем дату создания для команды add
                        if (commandName.equals("add")) {
                            commandHumanBeing.setCreationDate(LocalDateTime.now());
                        }
                    } else if (commandName.equals("removebyid")) {
                        if (parts.length > 1) {
                            try {
                                commandHumanBeing.setId(Long.parseLong(parts[1]));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка: ID должен быть числом");
                            }
                        }
                    } else if (parts.length > 1) {
                        commandHumanBeing.setName(parts[1]);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, commandHumanBeing, userId);
                    scriptOutput.append(response.getMessage()).append("\n");
                }
            } finally {
                executedFiles.remove(absolutePath);
            }

            return new ExecutionResponse(true, scriptOutput.toString().trim());
        } catch (IOException e) {
            return new ExecutionResponse(false, "Ошибка при чтении файла: " + e.getMessage());
        }
    }
}
package commands;

import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Exit extends Command {
    private final Console console;

    public Exit(Console console) {
        super("exit", "завершить работу клиента");
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Завершение работы клиента");
        return new ExecutionResponse(true, "Клиент отключен");
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class FilterStartsWithName extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public FilterStartsWithName(Console console, CollectionManager collectionManager) {
        super("filter_starts_with_name", "вывести элементы, значение поля name которых начинается с заданной подстроки");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: filter_starts_with_name, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }
        if (argument == null || argument.getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать подстроку для поля name");
        }

        String prefix = argument.getName();
        console.println("Ищем элементы с именем, начинающимся с: " + prefix);
        
        StringBuilder response = new StringBuilder("Элементы с именем, начинающимся с \"" + prefix + "\":\n");
        boolean found = false;
        int totalElements = 0;
        int matchingElements = 0;

        for (HumanBeing human : collectionManager.getCollection()) {
            totalElements++;
            console.println("Проверяем элемент: " + human.getName() + " (userId: " + human.getUserId() + ")");
            if (human.getName().startsWith(prefix) && human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                matchingElements++;
            }
        }

        console.println("Всего элементов в коллекции: " + totalElements);
        console.println("Найдено совпадающих элементов: " + matchingElements);

        if (!found) {
            response.append("Элементы не найдены.");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CommandManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Help extends Command {
    private final Console console;
    private final CommandManager commandManager;

    public Help(Console console, CommandManager commandManager) {
        super("help", "вывести справку по доступным командам");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: help, userId: " + userId);
        StringBuilder response = new StringBuilder("Доступные команды:\n");
        commandManager.getCommands().forEach((name, command) ->
                response.append(name).append(": ").append(command.getDescription()).append("\n")
        );
        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;

public class Info extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Info(Console console, CollectionManager collectionManager) {
        super("info", "вывести информацию о коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: info, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        int totalElements = collection.size();
        int userElements = 0;

        for (HumanBeing human : collection) {
            if (human.getUserId().equals(userId)) {
                userElements++;
            }
        }

        StringBuilder response = new StringBuilder();
        response.append("Тип коллекции: ").append(collection.getClass().getSimpleName()).append("\n");
        response.append("Дата инициализации: ").append(collectionManager.getInitializationDate()).append("\n");
        response.append("Всего элементов в коллекции: ").append(totalElements).append("\n");
        response.append("Ваших элементов в коллекции: ").append(userElements);

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Login extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Login(DatabaseManager dbManager, Console console) {
        super("login", "авторизоваться с существующим пользователем");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: login, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: " + "необходимо указать имя пользователя и пароль");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка авторизации: username=" + username);
        Integer resultId = dbManager.loginUser(username, password);
        if (resultId != null) {
            return new ExecutionResponse(true, String.valueOf(resultId));
        } else {
            return new ExecutionResponse(false, "Ошибка авторизации: неверный username или password");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashSet;
import java.util.Set;

public class PrintUniqueImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public PrintUniqueImpactSpeed(Console console, CollectionManager collectionManager) {
        super("print_unique_impact_speed", "вывести уникальные значения поля impactSpeed");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: print_unique_impact_speed, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        Set<Long> uniqueSpeeds = new HashSet<>();
        for (HumanBeing human : collectionManager.getCollection()) {
            if (human.getUserId().equals(userId)) {
                uniqueSpeeds.add(human.getImpactSpeed());
            }
        }

        if (uniqueSpeeds.isEmpty()) {
            return new ExecutionResponse(true, "У вас нет элементов в коллекции.");
        }

        StringBuilder response = new StringBuilder("Уникальные значения impactSpeed:\n");
        for (Long speed : uniqueSpeeds) {
            response.append(speed).append("\n");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Register extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Register(DatabaseManager dbManager, Console console) {
        super("register", "зарегистрировать нового пользователя");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: register, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать username и password");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка регистрации: username=" + username);

        Integer newUserId = dbManager.registerUser(username, password);
        if (newUserId != null) {
            return new ExecutionResponse(true, String.valueOf(newUserId));
        } else {
            return new ExecutionResponse(false, "Ошибка регистрации: пользователь уже существует или неверные данные");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class RemoveById extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveById(Console console, CollectionManager collectionManager) {
        super("removebyid", "удалить элемент из коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: removebyid, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }
        if (argument == null || argument.getId() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать id для удаления");
        }

        Long id = argument.getId();
        // Debug: Print collection contents
        console.println("Содержимое коллекции перед удалением id=" + id + ":");
        for (Long key : collectionManager.getCollectionMap().keySet()) {
            HumanBeing hb = collectionManager.getCollectionMap().get(key);
            console.println("id=" + hb.getId() + ", userId=" + hb.getUserId());
        }

        HumanBeing humanBeing = collectionManager.getCollectionMap().get(id);
        if (humanBeing == null) {
            console.println("Элемент с id " + id + " не найден в коллекции");
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " не существует в коллекции");
        }
        if (!humanBeing.getUserId().equals(userId)) {
            console.println("Элемент с id " + id + " принадлежит userId=" + humanBeing.getUserId());
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " принадлежит другому пользователю");
        }

        boolean success = collectionManager.remove(id, userId);
        if (success) {
            console.println("Элемент с id " + id + " успешно удален");
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно удален");
        } else {
            console.println("Ошибка удаления id=" + id + " из базы данных");
            return new ExecutionResponse(false, "Ошибка при удалении элемента с id " + id + ": не удалось удалить из базы данных");
        }
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;

public class RemoveHead extends Command {
    private final CollectionManager collectionManager;
    private final DatabaseManager databaseManager;
    private final Console console;

    public RemoveHead(CollectionManager collection, Console console, DatabaseManager databaseManager) {
        super("remove_head", "вывести и удалить первый элемент коллекции");
        this.collectionManager = collection;
        this.databaseManager = databaseManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: remove_head, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        if (collection.isEmpty()) {
            return new ExecutionResponse(false, "Коллекция пуста");
        }

        HumanBeing head = collection.stream()
                .filter(h -> h.getUserId().equals(userId))
                .findFirst()
                .orElse(null);

        if (head == null) {
            return new ExecutionResponse(false, "Нет элементов, принадлежащих пользователю с ID " + userId);
        }

        boolean success = collectionManager.remove(head.getId(), userId);
        if (success) {
            return new ExecutionResponse(true, "Первый элемент: " + head.toString() + "\nЭлемент успешно удален");
        } else {
            return new ExecutionResponse(false, "Ошибка при удалении первого элемента");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import java.util.List;

public class Show extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Show(Console console, CollectionManager collectionManager) {
        super("show", "вывести все элементы коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: show, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        StringBuilder response = new StringBuilder("Элементы коллекции:\n");
        
        List<HumanBeing> collection = collectionManager.getCollection();
        boolean found = false;
        int totalElements = 0;
        int userElements = 0;

        for (HumanBeing human : collection) {
            totalElements++;
            if (human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                userElements++;
            }
        }

        console.println("Всего элементов в коллекции: " + totalElements);
        console.println("Ваших элементов: " + userElements);

        if (!found) {
            response.append("У вас нет элементов в коллекции.");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Update extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Update(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("update", "обновить элемент коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        console.println("Выполняется команда: update, userId: " + userId);
        
        if (humanBeing == null) {
            return new ExecutionResponse(false, "Ошибка: объект HumanBeing не предоставлен");
        }
        
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        Long id = humanBeing.getId();
        if (id == null) {
            return new ExecutionResponse(false, "Ошибка: id не указан");
        }
        
        if (id <= 0) {
            return new ExecutionResponse(false, "Ошибка: id должен быть положительным числом");
        }

        // Check if the element exists and belongs to the user
        HumanBeing existingHuman = collectionManager.getCollectionMap().get(id);
        if (existingHuman == null) {
            return new ExecutionResponse(false, "Ошибка: элемент с указанным id не найден");
        }

        if (!existingHuman.getUserId().equals(userId)) {
            return new ExecutionResponse(false, "Ошибка: вы не можете изменить элемент, созданный другим пользователем");
        }

        // Update the element
        boolean success = collectionManager.update(id, humanBeing, userId);
        if (success) {
            return new ExecutionResponse(true, "Элемент успешно обновлен");
        } else {
            return new ExecutionResponse(false, "Ошибка при обновлении элемента");
        }
    }
}
package main;

import managers.CollectionManager;
import managers.CommandManager;
import managers.DatabaseManager;
import server.Server;
import utility.Console;
import utility.StandardConsole;

public class ServerMain {
    public static void main(String[] args) {
        Console console = new StandardConsole();
        DatabaseManager databaseManager = new DatabaseManager();
        CollectionManager collectionManager = new CollectionManager(databaseManager);
        CommandManager commandManager = new CommandManager(console, collectionManager, databaseManager);
        Server server = new Server(5000, commandManager);
        server.run();
    }
}
package managers;

import models.HumanBeing;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CollectionManager {
    private final Map<Long, HumanBeing> collection;
    private final DatabaseManager dbManager;
    private final LocalDateTime initializationDate;

    public CollectionManager(DatabaseManager dbManager) {
        this.collection = new ConcurrentHashMap<>();
        this.dbManager = dbManager;
        this.initializationDate = LocalDateTime.now();
    }

    public List<HumanBeing> getCollection() {
        return dbManager.loadHumanBeings();
    }

    public LocalDateTime getInitializationDate() {
        return initializationDate;
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || userId == null) {
            return false;
        }
        if (dbManager.add(humanBeing, userId)) {
            collection.put(humanBeing.getId(), humanBeing);
            return true;
        }
        return false;
    }

    public boolean update(Long id, HumanBeing humanBeing, Integer userId) {
        return dbManager.updateHumanBeing(id, humanBeing, userId);
    }

    public boolean remove(Long id, Integer userId) {
        return dbManager.removeHumanBeing(id, userId);
    }

    public boolean clear(Integer userId) {
        return dbManager.clearHumanBeings(userId);
    }

    public Map<Long, HumanBeing> getCollectionMap() {
        return collection;
    }
}
package managers;

import commands.*;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashMap;
import java.util.Map;

public class CommandManager {
    private final Map<String, Command> commands = new HashMap<>();
    private final Console console;

    public CommandManager(Console console, CollectionManager collectionManager, DatabaseManager databaseManager) {
        this.console = console;
        commands.put("add", new Add(collectionManager));
        commands.put("update", new Update(console, collectionManager, databaseManager));
        commands.put("remove_head", new RemoveHead(collectionManager, console, databaseManager));
        commands.put("clear", new Clear(console, collectionManager, databaseManager));
        commands.put("info", new Info(console, collectionManager));
        commands.put("show", new Show(console, collectionManager));
        commands.put("login", new Login(databaseManager, console));
        commands.put("register", new Register(databaseManager, console));
        commands.put("exit", new Exit(console));
        commands.put("help", new Help(console, this));
        commands.put("filter_starts_with_name", new FilterStartsWithName(console, collectionManager));
        commands.put("print_unique_impact_speed", new PrintUniqueImpactSpeed(console, collectionManager));
        commands.put("count_less_than_impact_speed", new CountLessThanImpactSpeed(console, collectionManager));
        commands.put("execute_script", new ExecuteScript(console, this));
        commands.put("removebyid", new RemoveById(console, collectionManager));
    }

    public ExecutionResponse executeCommand(String commandName, HumanBeing humanBeing, Integer userId) {
        Command command = commands.get(commandName);
        if (command == null) {
            return new ExecutionResponse(false, "Команда '" + commandName + "' не найдена. Введите 'help' для списка команд.");
        }
        return command.execute(humanBeing, userId);
    }

    public Map<String, Command> getCommands() {
        return commands;
    }
}
package managers;

import models.*;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class DatabaseManager {
    private final String url = "jdbc:postgresql://localhost:5432/studs";
    private final String user = "s434931";
    private final String password = "250806";
    private Connection connection;
    private final Map<Long, HumanBeing> collection;

    public DatabaseManager() {
        this.collection = new ConcurrentHashMap<>();
        connect();
        loadHumanBeings();
    }

    private void connect() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
            }
            connection = DriverManager.getConnection(url, user, password);
            System.out.println("Подключение к базе данных установлено: " + url);
        } catch (SQLException e) {
            System.err.println("Ошибка подключения к базе данных: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void close() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                System.out.println("Соединение с базой данных закрыто");
            }
        } catch (SQLException e) {
            System.err.println("Ошибка при закрытии соединения с базой данных: " + e.getMessage());
        }
    }

    public Map<Long, HumanBeing> getCollection() {
        return collection;
    }

    public List<HumanBeing> loadHumanBeings() {
        collection.clear();
        List<HumanBeing> humans = new ArrayList<>();
        String query = "SELECT * FROM human_beings";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            while (rs.next()) {
                HumanBeing human = new HumanBeing();
                human.setId(rs.getLong("id"));
                human.setName(rs.getString("name"));
                human.setCoordinates(new Coordinates(
                        rs.getDouble("coordinate_x"),
                        rs.getFloat("coordinate_y")
                ));
                human.setCreationDate(rs.getTimestamp("creation_date").toLocalDateTime());
                human.setRealHero(rs.getBoolean("real_hero"));
                human.setHasToothpick(rs.getObject("has_toothpick") != null ? rs.getBoolean("has_toothpick") : null);
                human.setImpactSpeed(rs.getLong("impact_speed"));
                human.setWeaponType(WeaponType.valueOf(rs.getString("weapon_type")));
                human.setMood(rs.getString("mood"));
                human.setCar(new Car(rs.getString("car_name")));
                human.setUserId(rs.getInt("user_id"));
                collection.put(human.getId(), human);
                humans.add(human);
            }
            System.out.println("Коллекция загружена из базы данных: " + collection.size() + " элементов");
            return humans;
        } catch (SQLException e) {
            System.err.println("Ошибка загрузки коллекции: " + e.getMessage());
            return humans;
        }
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        String sql = "INSERT INTO human_beings (name, coordinate_x, coordinate_y, creation_date, impact_speed, real_hero, has_toothpick, weapon_type, mood, car_name, user_id) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setInt(11, userId);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    long id = rs.getLong(1);
                    humanBeing.setId(id);
                    return true;
                }
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка при добавлении элемента: " + e.getMessage());
            return false;
        }
    }

    public boolean removeHumanBeing(Long id, Integer userId) {
        if (id == null || userId == null) return false;
        String query = "DELETE FROM human_beings WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setLong(1, id);
            pstmt.setInt(2, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.remove(id);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка удаления: " + e.getMessage());
            return false;
        }
    }

    public boolean updateHumanBeing(Long id, HumanBeing humanBeing, Integer userId) {
        if (id == null || humanBeing == null || userId == null) return false;
        String query = "UPDATE human_beings SET name = ?, coordinate_x = ?, coordinate_y = ?, creation_date = ?, impact_speed = ?, real_hero = ?, has_toothpick = ?, weapon_type = ?, mood = ?, car_name = ? WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setLong(11, id);
            pstmt.setInt(12, userId);

            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                humanBeing.setId(id);
                humanBeing.setUserId(userId);
                collection.put(id, humanBeing);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка обновления: " + e.getMessage());
            return false;
        }
    }

    public boolean clearHumanBeings(Integer userId) {
        if (userId == null) return false;
        String query = "DELETE FROM human_beings WHERE user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setInt(1, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.entrySet().removeIf(entry -> entry.getValue().getUserId().equals(userId));
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка очистки: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    public Integer loginUser(String username, String password) {
        String query = "SELECT id, password FROM users WHERE username = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, username);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                String storedPassword = rs.getString("password");
                String hashedInputPassword = hashPassword(password);
                if (hashedInputPassword.equals(storedPassword)) {
                    return rs.getInt("id");
                }
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка авторизации: " + e.getMessage());
            return null;
        }
    }

    public Integer registerUser(String username, String password) {
        String query = "INSERT INTO users (username, password) VALUES (?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            String hashedPassword = hashPassword(password);
            System.out.println("Debug - Registration:");
            System.out.println("Username: " + username);
            System.out.println("Password: " + password);
            System.out.println("Hashed password: " + hashedPassword);
            pstmt.setString(1, username);
            pstmt.setString(2, hashedPassword);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt("id");
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка регистрации: " + e.getMessage());
            return null;
        }
    }

    private String hashPassword(String password) {
        int hash = password.hashCode();
        hash = hash * 31 + "SALT".hashCode();
        hash = hash * 31 + password.length();
        return String.format("%d", hash);
    }
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return String.format("(x=%.2f, y=%.2f)", x, y);
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return String.format("HumanBeing{id=%d, name='%s', coordinates=%s, creationDate=%s, realHero=%b, hasToothpick=%s, impactSpeed=%d, weaponType=%s, mood=%s, car=%s, userId=%d}",
                id, name, coordinates, creationDate, realHero, hasToothpick, impactSpeed, weaponType, mood, car, userId);
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package server;

import managers.CommandManager;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    private final int port;
    private final CommandManager commandManager;

    public Server(int port, CommandManager commandManager) {
        this.port = port;
        this.commandManager = commandManager;
    }

    public void run() {
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Сервер запущен на порту " + port);
            while (true) {
                try (Socket clientSocket = serverSocket.accept()) {
                    System.out.println("Клиент подключен: " + clientSocket.getInetAddress());
                    handleClient(clientSocket);
                } catch (IOException e) {
                    System.err.println("Ошибка обработки клиента: " + e.getMessage());
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка сервера: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleClient(Socket clientSocket) throws IOException {
        try (ObjectInputStream input = new ObjectInputStream(clientSocket.getInputStream());
             ObjectOutputStream output = new ObjectOutputStream(clientSocket.getOutputStream())) {

            while (!clientSocket.isClosed()) {
                try {
                    String commandName = (String) input.readObject();
                    Object argument = input.readObject();
                    Integer userId = (Integer) input.readObject();

                    System.out.println("Получен запрос: command=" + commandName + ", userId=" + userId);
                    if (argument != null) {
                        if (argument instanceof HumanBeing) {
                            System.out.println("Аргумент: " + ((HumanBeing) argument).getName());
                        } else if (argument instanceof Long) {
                            System.out.println("Аргумент: id=" + argument);
                        } else {
                            System.out.println("Аргумент: " + argument);
                        }
                    } else {
                        System.out.println("Аргумент: null");
                    }

                    HumanBeing humanBeing = null;
                    if (argument instanceof HumanBeing) {
                        humanBeing = (HumanBeing) argument;
                    } else if (commandName.equals("removebyid") && argument instanceof Long) {
                        humanBeing = new HumanBeing();
                        humanBeing.setId((Long) argument);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, humanBeing, userId);

                    output.writeObject(response);
                    output.flush();

                    if (commandName.equals("exit")) {
                        System.out.println("Клиент отключен: " + clientSocket.getInetAddress());
                        break;
                    }
                } catch (ClassNotFoundException e) {
                    System.err.println("Ошибка чтения данных: " + e.getMessage());
                    output.writeObject(new ExecutionResponse(false, "Ошибка чтения данных: " + e.getMessage()));
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка обработки клиента: " + e.getMessage());
            throw e;
        }
    }
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;

public class ExecutionResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private final boolean success;
    private final String message;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        // Name
        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        // Coordinate X
        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        // Coordinate Y
        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        // Устанавливаем координаты один раз после успешного ввода x и y
        humanBeing.setCoordinates(new Coordinates(x, y));

        // Real Hero
        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        // Has Toothpick
        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        // Impact Speed
        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        // Weapon Type
        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        // Mood
        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood.valueOf(moodInput.toUpperCase()); // Validate input
                humanBeing.setMood(moodInput);
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        // Car
        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        // Creation Date (set automatically)
        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;
import java.io.Serializable;

public class Request implements Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }

    @Override
    public String toString() {
        return "Request{commandName='" + commandName + "', argument=" + argument + ", userId=" + userId + "}";
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package main;

import models.Car;
import models.HumanBeing;
import models.Mood;
import models.WeaponType;
import utility.*;
import utility.Console;

import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

public class ClientMain {
    private static Integer userId = null;
    private static List<String> users = new ArrayList<>();

    public static void main(String[] args) {
        String host = "localhost";
        int port = 5000;
        Console console = new StandardConsole();

        try (Socket socket = new Socket(host, port);
             ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
             ObjectInputStream input = new ObjectInputStream(socket.getInputStream())) {

            console.println("Подключено к серверу: " + host + ":" + port);

            while (true) {
                console.println("Введите команду: ");
                String command = console.read().trim();
                Object argument = null;

                if (command.equals("exit")) {
                    output.writeObject(command);
                    output.writeObject(null);
                    output.writeObject(userId);
                    break;
                }

                String[] parts = command.split("\\s+", 2);
                String commandName = parts[0].toLowerCase();

                if (commandName.equals("delete_user")) {
                    if (userId == null) {
                        console.println("Ошибка: необходимо авторизоваться");
                        continue;
                    }
                    output.writeObject("get_users");
                    output.writeObject(null);
                    output.writeObject(userId);
                    output.flush();

                    ExecutionResponse response = (ExecutionResponse) input.readObject();
                    if (!response.isSuccess()) {
                        console.println("Ошибка при получении списка пользователей: " + response.getMessage());
                        continue;
                    }

                    String[] usersList = response.getMessage().split("\n");
                    users.clear();
                    for (String user : usersList) {
                        if (!user.trim().isEmpty()) {
                            users.add(user.trim());
                        }
                    }

                    if (users.isEmpty()) {
                        console.println("Список пользователей пуст");
                        continue;
                    }

                    console.println("Список пользователей:");
                    for (int i = 0; i < users.size(); i++) {
                        console.println((i + 1) + ". " + users.get(i));
                    }

                    console.println("Введите номер пользователя для удаления:");
                    String inputStr = console.read().trim();
                    int userNumber;
                    try {
                        userNumber = Integer.parseInt(inputStr);
                        if (userNumber < 1 || userNumber > users.size()) {
                            console.println("Ошибка: неверный номер пользователя");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректный номер");
                        continue;
                    }

                    String usernameToDelete = users.get(userNumber - 1);
                    console.println("Вы уверены, что хотите удалить пользователя " + usernameToDelete + "? (да/нет)");
                    String confirmation = console.read().trim().toLowerCase();
                    if (!confirmation.equals("да")) {
                        console.println("Удаление отменено");
                        continue;
                    }

                    users.remove(userNumber - 1);
                    console.println("Пользователь " + usernameToDelete + " успешно удален");
                    continue;
                }

                if (commandName.equals("register") || commandName.equals("login")) {
                    console.println("Введите имя пользователя (не пустое):");
                    String username = console.read().trim();
                    if (username.isEmpty()) {
                        console.println("Ошибка: имя пользователя не может быть пустым");
                        continue;
                    }

                    console.println("Введите пароль (не пустой):");
                    String password = console.read().trim();
                    if (password.isEmpty()) {
                        console.println("Ошибка: пароль не может быть пустым");
                        continue;
                    }

                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(username);
                    humanBeing.setCar(new Car(password));
                    argument = humanBeing;
                } else if (commandName.equals("execute_script")) {
                    console.println("Введите путь к файлу скрипта:");
                    String scriptPath = console.read().trim();
                    if (scriptPath.isEmpty()) {
                        console.println("Ошибка: путь к файлу не может быть пустым");
                        continue;
                    }
                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(scriptPath);
                    argument = humanBeing;
                } else if (commandName.equals("removebyid")) {
                    console.println("Введите id элемента для удаления (целое положительное число):");
                    String idInput = console.read().trim();
                    Long id;
                    try {
                        id = Long.parseLong(idInput);
                        if (id <= 0) {
                            console.println("Ошибка: id должен быть положительным числом");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректное целое число для id");
                        continue;
                    }
                    argument = id;
                } else {
                    if (userId == null) {
                        console.println("Ошибка: необходимо войти в систему (login) или зарегистрироваться (register)");
                        continue;
                    }

                    if (commandName.equals("add")) {
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("update")) {
                        console.println("Введите id элемента для обновления (целое положительное число):");
                        String idInput = console.read().trim();
                        Long id;
                        try {
                            id = Long.parseLong(idInput);
                            if (id <= 0) {
                                console.println("Ошибка: id должен быть положительным числом");
                                continue;
                            }
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число для id");
                            continue;
                        }
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            humanBeing.setId(id);
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("filter_starts_with_name")) {
                        console.println("Введите имя (не пустое):");
                        String name = console.read().trim();
                        if (name.isEmpty()) {
                            console.println("Ошибка: имя не может быть пустым");
                            continue;
                        }
                        HumanBeing humanBeing = new HumanBeing();
                        humanBeing.setName(name);
                        argument = humanBeing;
                    } else if (commandName.equals("count_less_than_impact_speed")) {
                        console.println("Введите impactSpeed (целое число):");
                        String impactSpeedInput = console.read().trim();
                        try {
                            long impactSpeed = Long.parseLong(impactSpeedInput);
                            HumanBeing humanBeing = new HumanBeing();
                            humanBeing.setImpactSpeed(impactSpeed);
                            argument = humanBeing;
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число");
                            continue;
                        }
                    }
                }

                output.writeObject(commandName);
                output.writeObject(argument);
                output.writeObject(userId);
                output.flush();

                ExecutionResponse response = (ExecutionResponse) input.readObject();
                console.println("Ответ сервера: " + response.getMessage());

                if (commandName.equals("execute_script")) {
                    if (response.isSuccess()) {
                        console.println("Результат выполнения скрипта:");
                        String message = response.getMessage();
                        if (message != null && !message.isEmpty()) {
                            String[] lines = message.split("\\r?\\n");
                            for (String line : lines) {
                                console.println(line);
                            }
                        } else {
                            console.println("Пустой результат от сервера");
                        }
                    } else {
                        console.println("Ошибка выполнения скрипта: " + response.getMessage());
                    }
                }

                if ((commandName.equals("login") || commandName.equals("register")) && response.isSuccess()) {
                    try {
                        userId = Integer.parseInt(response.getMessage());
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: некорректный userId от сервера");
                    }
                }
            }
        } catch (IOException | ClassNotFoundException e) {
            console.println("Ошибка клиента: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
package main.gui;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.stage.Stage;

import java.util.Locale;
import java.util.ResourceBundle;

public class MainApp extends Application {
    private static Locale currentLocale = new Locale("ru", "RU");

    public static void setLocale(Locale locale) {
        currentLocale = locale;
    }

    public static Locale getLocale() {
        return currentLocale;
    }

    public static ResourceBundle getBundle() {
        return ResourceBundle.getBundle("main.gui.locale.messages", currentLocale);
    }

    @Override
    public void start(Stage primaryStage) throws Exception {
        ResourceBundle bundle = getBundle();
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/main/gui/views/auth.fxml"), bundle);
        Scene scene = new Scene(loader.load());
        primaryStage.setTitle(bundle.getString("window.auth"));
        primaryStage.setScene(scene);
        primaryStage.show();
    }

    public static void main(String[] args) {
        launch(args);
    }
}
package main.gui;

import utility.ExecutionResponse;
import models.HumanBeing;
import models.Car;

import java.io.*;
import java.net.Socket;

public class NetworkClient {
    private final String host;
    private final int port;

    public NetworkClient(String host, int port) {
        this.host = host;
        this.port = port;
    }

    public ExecutionResponse sendAuthCommand(String command, String username, String password) {
        try (Socket socket = new Socket(host, port);
             ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
             ObjectInputStream input = new ObjectInputStream(socket.getInputStream())) {

            // Формируем аргумент, как в консольном клиенте
            HumanBeing humanBeing = new HumanBeing();
            humanBeing.setName(username);
            humanBeing.setCar(new Car(password));

            output.writeObject(command); // "login" или "register"
            output.writeObject(humanBeing);
            output.writeObject(null); // userId для логина/регистрации = null
            output.flush();

            ExecutionResponse response = (ExecutionResponse) input.readObject();
            return response;
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка клиента: " + e.getMessage());
        }
    }
}
package main.gui.controllers;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.MainApp;
import main.gui.NetworkClient;
import utility.ExecutionResponse;

import java.util.Locale;

public class AuthController {
    @FXML private TextField usernameField;
    @FXML private PasswordField passwordField;
    @FXML private Button loginButton;
    @FXML private Button registerButton;
    @FXML private ComboBox<String> languageBox;
    @FXML private Label messageLabel;

    private final NetworkClient networkClient = new NetworkClient("localhost", 5000);

    @FXML
    private void initialize() {
        languageBox.getItems().setAll("Русский", "Македонский", "Latviešu", "Español (Colombia)");
        Locale current = MainApp.getLocale();
        int idx = 0;
        if (current.getLanguage().equals("ru")) idx = 0;
        else if (current.getLanguage().equals("mk")) idx = 1;
        else if (current.getLanguage().equals("lv")) idx = 2;
        else if (current.getLanguage().equals("es")) idx = 3;
        languageBox.getSelectionModel().select(idx);

        languageBox.setOnAction(event -> {
            switch (languageBox.getValue()) {
                case "Русский":
                    MainApp.setLocale(new Locale("ru", "RU"));
                    break;
                case "Македонский":
                    MainApp.setLocale(new Locale("mk", "MK"));
                    break;
                case "Latviešu":
                    MainApp.setLocale(new Locale("lv", "LV"));
                    break;
                case "Español (Colombia)":
                    MainApp.setLocale(new Locale("es", "CO"));
                    break;
            }
            java.util.ResourceBundle.clearCache();
            reload();
        });
    }

    private void reload() {
        Stage stage = (Stage) usernameField.getScene().getWindow();
        stage.close();
        try {
            new MainApp().start(new Stage());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @FXML
    private void handleLogin(ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.empty"));
            return;
        }
        ExecutionResponse response = networkClient.sendAuthCommand("login", username, password);
        if (response.isSuccess()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.success"));
            // TODO: переход на главное окно
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.fail") + " " + response.getMessage());
        }
    }

    @FXML
    private void handleRegister(ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.empty"));
            return;
        }
        ExecutionResponse response = networkClient.sendAuthCommand("register", username, password);
        if (response.isSuccess()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.success"));
            // Можно автоматически залогиниться или перейти на другое окно
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.fail") + " " + response.getMessage());
        }
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;

public class MainController {
    @FXML private Label userLabel;
    @FXML private TableView<?> tableView; // замените ? на ваш класс-модель
    @FXML private Canvas canvas;

    @FXML
    private void initialize() {
        userLabel.setText("User: ..."); // тут отобразите имя пользователя из сессии
        // Настройка TableView, загрузка данных с сервера
    }

    @FXML
    private void handleCanvasClick(MouseEvent event) {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        // TODO: обработка клика, выделение объекта, вывод информации
    }

    // Добавьте методы для фильтрации, сортировки, обновления таблицы, работы с графикой и т.д.
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return "HumanBeing{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", coordinates=" + coordinates +
                ", creationDate=" + creationDate +
                ", realHero=" + realHero +
                ", hasToothpick=" + hasToothpick +
                ", impactSpeed=" + impactSpeed +
                ", weaponType=" + weaponType +
                ", mood=" + mood +
                ", car=" + car +
                ", userId=" + userId +
                '}';
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;

public class ExecutionResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private final boolean success;
    private final String message;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        humanBeing.setCoordinates(new Coordinates(x, y));

        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood mood = Mood.valueOf(moodInput.toUpperCase());
                humanBeing.setMood(mood.toString());
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;

public class Request implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package commands;

import models.HumanBeing;
import utility.ExecutionResponse;
import managers.CollectionManager;

public class Add extends Command {
    private final CollectionManager collectionManager;

    public Add(CollectionManager collectionManager) {
        super("add", "добавить новый элемент в коллекцию");
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null) {
            return new ExecutionResponse(false, "Ошибка: объект не может быть null");
        }
        humanBeing.setUserId(userId);
        boolean success = collectionManager.add(humanBeing, userId);
        if (success) {
            return new ExecutionResponse(true, "Элемент успешно добавлен с id: " + humanBeing.getId());
        } else {
            return new ExecutionResponse(false, "Не удалось добавить элемент");
        }
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Clear extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Clear(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("clear", "очистить коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: clear, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        boolean success = collectionManager.clear(userId);
        if (success) {
            return new ExecutionResponse(true, "Коллекция успешно очищена для пользователя с ID " + userId);
        } else {
            return new ExecutionResponse(false, "Ошибка при очистке коллекции");
        }
    }
}
package commands;

import models.HumanBeing;
import utility.ExecutionResponse;

public abstract class Command {
    protected String name;
    protected String description;

    public Command(String name, String description) {
        this.name = name;
        this.description = description;
    }

    public abstract ExecutionResponse execute(HumanBeing argument, Integer userId);

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class CountLessThanImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public CountLessThanImpactSpeed(Console console, CollectionManager collectionManager) {
        super("count_less_than_impact_speed", "вывести количество элементов, значение поля impactSpeed которых меньше заданного");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: count_less_than_impact_speed, userId: " + userId);
        if (argument == null || argument.getImpactSpeed() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать значение impactSpeed");
        }

        long threshold = argument.getImpactSpeed();
        long count = collectionManager.getCollection().stream()
                .filter(h -> h.getUserId().equals(userId))
                .filter(h -> h.getImpactSpeed() < threshold)
                .count();

        return new ExecutionResponse(true, "Количество элементов с impactSpeed меньше " + threshold + ": " + count);
    }
}
package commands;

import models.HumanBeing;
import models.Coordinates;
import models.Car;
import models.WeaponType;
import models.Mood;
import utility.Console;
import utility.ExecutionResponse;
import managers.CommandManager;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;

public class ExecuteScript extends Command {
    private final Console console;
    private final CommandManager commandManager;
    private final Set<String> executedFiles = new HashSet<>();
    private final List<String> inputLines = new ArrayList<>();

    public ExecuteScript(Console console, CommandManager commandManager) {
        super("execute_script", "исполнить скрипт из файла");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || humanBeing.getName() == null || humanBeing.getName().trim().isEmpty()) {
            return new ExecutionResponse(false, "Требуется путь к файлу скрипта");
        }

        String scriptPath = humanBeing.getName().trim();

        try {
            String absolutePath = Paths.get(scriptPath).toAbsolutePath().toString();

            if (executedFiles.contains(absolutePath)) {
                return new ExecutionResponse(false, "Обнаружена рекурсия: файл " + scriptPath + " уже выполняется");
            }

            executedFiles.add(absolutePath);
            StringBuilder scriptOutput = new StringBuilder();

            try (BufferedReader reader = new BufferedReader(new FileReader(absolutePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith("#")) continue;

                    String[] parts = line.split("\\s+", 2);
                    String commandName = parts[0].toLowerCase();
                    HumanBeing commandHumanBeing = new HumanBeing();

                    if (commandName.equals("execute_script")) {
                        commandHumanBeing.setName(parts.length > 1 ? parts[1] : "");
                    } else if (commandName.equals("add") || commandName.equals("update")) {
                        // Читаем следующие 9 строк для команды add/update
                        inputLines.clear();
                        for (int i = 0; i < 9; i++) {
                            String nextLine = reader.readLine();
                            if (nextLine == null) {
                                return new ExecutionResponse(false, "Неожиданный конец файла при чтении параметров команды " + commandName);
                            }
                            nextLine = nextLine.trim();
                            if (nextLine.isEmpty()) {
                                i--; // Пропускаем пустые строки
                                continue;
                            }
                            inputLines.add(nextLine);
                        }
                        // Устанавливаем параметры в объект HumanBeing в правильном порядке
                        if (inputLines.size() >= 1) commandHumanBeing.setName(inputLines.get(0));
                        if (inputLines.size() >= 3) {
                            try {
                                double x = Double.parseDouble(inputLines.get(1));
                                float y = Float.parseFloat(inputLines.get(2));
                                commandHumanBeing.setCoordinates(new Coordinates(x, y));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении координат: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 4) commandHumanBeing.setRealHero(Boolean.parseBoolean(inputLines.get(3)));
                        if (inputLines.size() >= 5) commandHumanBeing.setHasToothpick(Boolean.parseBoolean(inputLines.get(4)));
                        if (inputLines.size() >= 6) {
                            try {
                                commandHumanBeing.setImpactSpeed(Long.parseLong(inputLines.get(5)));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении impactSpeed: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 7) {
                            try {
                                commandHumanBeing.setWeaponType(WeaponType.valueOf(inputLines.get(6)));
                            } catch (IllegalArgumentException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении weaponType: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 8) commandHumanBeing.setMood(inputLines.get(7));
                        if (inputLines.size() >= 9) {
                            String carName = inputLines.get(8);
                            commandHumanBeing.setCar(new Car(carName));
                        }
                        // Устанавливаем дату создания для команды add
                        if (commandName.equals("add")) {
                            commandHumanBeing.setCreationDate(LocalDateTime.now());
                        }
                    } else if (commandName.equals("removebyid")) {
                        if (parts.length > 1) {
                            try {
                                commandHumanBeing.setId(Long.parseLong(parts[1]));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка: ID должен быть числом");
                            }
                        }
                    } else if (parts.length > 1) {
                        commandHumanBeing.setName(parts[1]);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, commandHumanBeing, userId);
                    scriptOutput.append(response.getMessage()).append("\n");
                }
            } finally {
                executedFiles.remove(absolutePath);
            }

            return new ExecutionResponse(true, scriptOutput.toString().trim());
        } catch (IOException e) {
            return new ExecutionResponse(false, "Ошибка при чтении файла: " + e.getMessage());
        }
    }
}
package commands;

import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Exit extends Command {
    private final Console console;

    public Exit(Console console) {
        super("exit", "завершить работу клиента");
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Завершение работы клиента");
        return new ExecutionResponse(true, "Клиент отключен");
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class FilterStartsWithName extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public FilterStartsWithName(Console console, CollectionManager collectionManager) {
        super("filter_starts_with_name", "вывести элементы, значение поля name которых начинается с заданной подстроки");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: filter_starts_with_name, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }
        if (argument == null || argument.getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать подстроку для поля name");
        }

        String prefix = argument.getName();
        console.println("Ищем элементы с именем, начинающимся с: " + prefix);
        
        StringBuilder response = new StringBuilder("Элементы с именем, начинающимся с \"" + prefix + "\":\n");
        boolean found = false;
        int totalElements = 0;
        int matchingElements = 0;

        for (HumanBeing human : collectionManager.getCollection()) {
            totalElements++;
            console.println("Проверяем элемент: " + human.getName() + " (userId: " + human.getUserId() + ")");
            if (human.getName().startsWith(prefix) && human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                matchingElements++;
            }
        }

        console.println("Всего элементов в коллекции: " + totalElements);
        console.println("Найдено совпадающих элементов: " + matchingElements);

        if (!found) {
            response.append("Элементы не найдены.");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CommandManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Help extends Command {
    private final Console console;
    private final CommandManager commandManager;

    public Help(Console console, CommandManager commandManager) {
        super("help", "вывести справку по доступным командам");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: help, userId: " + userId);
        StringBuilder response = new StringBuilder("Доступные команды:\n");
        commandManager.getCommands().forEach((name, command) ->
                response.append(name).append(": ").append(command.getDescription()).append("\n")
        );
        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;

public class Info extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Info(Console console, CollectionManager collectionManager) {
        super("info", "вывести информацию о коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: info, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        int totalElements = collection.size();
        int userElements = 0;

        for (HumanBeing human : collection) {
            if (human.getUserId().equals(userId)) {
                userElements++;
            }
        }

        StringBuilder response = new StringBuilder();
        response.append("Тип коллекции: ").append(collection.getClass().getSimpleName()).append("\n");
        response.append("Дата инициализации: ").append(collectionManager.getInitializationDate()).append("\n");
        response.append("Всего элементов в коллекции: ").append(totalElements).append("\n");
        response.append("Ваших элементов в коллекции: ").append(userElements);

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Login extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Login(DatabaseManager dbManager, Console console) {
        super("login", "авторизоваться с существующим пользователем");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: login, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: " + "необходимо указать имя пользователя и пароль");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка авторизации: username=" + username);
        Integer resultId = dbManager.loginUser(username, password);
        if (resultId != null) {
            return new ExecutionResponse(true, String.valueOf(resultId));
        } else {
            return new ExecutionResponse(false, "Ошибка авторизации: неверный username или password");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashSet;
import java.util.Set;

public class PrintUniqueImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public PrintUniqueImpactSpeed(Console console, CollectionManager collectionManager) {
        super("print_unique_impact_speed", "вывести уникальные значения поля impactSpeed");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: print_unique_impact_speed, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        Set<Long> uniqueSpeeds = new HashSet<>();
        for (HumanBeing human : collectionManager.getCollection()) {
            if (human.getUserId().equals(userId)) {
                uniqueSpeeds.add(human.getImpactSpeed());
            }
        }

        if (uniqueSpeeds.isEmpty()) {
            return new ExecutionResponse(true, "У вас нет элементов в коллекции.");
        }

        StringBuilder response = new StringBuilder("Уникальные значения impactSpeed:\n");
        for (Long speed : uniqueSpeeds) {
            response.append(speed).append("\n");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Register extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Register(DatabaseManager dbManager, Console console) {
        super("register", "зарегистрировать нового пользователя");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: register, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать username и password");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка регистрации: username=" + username);

        Integer newUserId = dbManager.registerUser(username, password);
        if (newUserId != null) {
            return new ExecutionResponse(true, String.valueOf(newUserId));
        } else {
            return new ExecutionResponse(false, "Ошибка регистрации: пользователь уже существует или неверные данные");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class RemoveById extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveById(Console console, CollectionManager collectionManager) {
        super("removebyid", "удалить элемент из коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: removebyid, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }
        if (argument == null || argument.getId() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать id для удаления");
        }

        Long id = argument.getId();
        // Debug: Print collection contents
        console.println("Содержимое коллекции перед удалением id=" + id + ":");
        for (Long key : collectionManager.getCollectionMap().keySet()) {
            HumanBeing hb = collectionManager.getCollectionMap().get(key);
            console.println("id=" + hb.getId() + ", userId=" + hb.getUserId());
        }

        HumanBeing humanBeing = collectionManager.getCollectionMap().get(id);
        if (humanBeing == null) {
            console.println("Элемент с id " + id + " не найден в коллекции");
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " не существует в коллекции");
        }
        if (!humanBeing.getUserId().equals(userId)) {
            console.println("Элемент с id " + id + " принадлежит userId=" + humanBeing.getUserId());
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " принадлежит другому пользователю");
        }

        boolean success = collectionManager.remove(id, userId);
        if (success) {
            console.println("Элемент с id " + id + " успешно удален");
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно удален");
        } else {
            console.println("Ошибка удаления id=" + id + " из базы данных");
            return new ExecutionResponse(false, "Ошибка при удалении элемента с id " + id + ": не удалось удалить из базы данных");
        }
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;

public class RemoveHead extends Command {
    private final CollectionManager collectionManager;
    private final DatabaseManager databaseManager;
    private final Console console;

    public RemoveHead(CollectionManager collection, Console console, DatabaseManager databaseManager) {
        super("remove_head", "вывести и удалить первый элемент коллекции");
        this.collectionManager = collection;
        this.databaseManager = databaseManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: remove_head, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        if (collection.isEmpty()) {
            return new ExecutionResponse(false, "Коллекция пуста");
        }

        HumanBeing head = collection.stream()
                .filter(h -> h.getUserId().equals(userId))
                .findFirst()
                .orElse(null);

        if (head == null) {
            return new ExecutionResponse(false, "Нет элементов, принадлежащих пользователю с ID " + userId);
        }

        boolean success = collectionManager.remove(head.getId(), userId);
        if (success) {
            return new ExecutionResponse(true, "Первый элемент: " + head.toString() + "\nЭлемент успешно удален");
        } else {
            return new ExecutionResponse(false, "Ошибка при удалении первого элемента");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import java.util.List;

public class Show extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Show(Console console, CollectionManager collectionManager) {
        super("show", "вывести все элементы коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: show, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        StringBuilder response = new StringBuilder("Элементы коллекции:\n");
        
        List<HumanBeing> collection = collectionManager.getCollection();
        boolean found = false;
        int totalElements = 0;
        int userElements = 0;

        for (HumanBeing human : collection) {
            totalElements++;
            if (human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                userElements++;
            }
        }

        console.println("Всего элементов в коллекции: " + totalElements);
        console.println("Ваших элементов: " + userElements);

        if (!found) {
            response.append("У вас нет элементов в коллекции.");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Update extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Update(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("update", "обновить элемент коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        console.println("Выполняется команда: update, userId: " + userId);
        
        if (humanBeing == null) {
            return new ExecutionResponse(false, "Ошибка: объект HumanBeing не предоставлен");
        }
        
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        Long id = humanBeing.getId();
        if (id == null) {
            return new ExecutionResponse(false, "Ошибка: id не указан");
        }
        
        if (id <= 0) {
            return new ExecutionResponse(false, "Ошибка: id должен быть положительным числом");
        }

        // Check if the element exists and belongs to the user
        HumanBeing existingHuman = collectionManager.getCollectionMap().get(id);
        if (existingHuman == null) {
            return new ExecutionResponse(false, "Ошибка: элемент с указанным id не найден");
        }

        if (!existingHuman.getUserId().equals(userId)) {
            return new ExecutionResponse(false, "Ошибка: вы не можете изменить элемент, созданный другим пользователем");
        }

        // Update the element
        boolean success = collectionManager.update(id, humanBeing, userId);
        if (success) {
            return new ExecutionResponse(true, "Элемент успешно обновлен");
        } else {
            return new ExecutionResponse(false, "Ошибка при обновлении элемента");
        }
    }
}
package main;

import managers.CollectionManager;
import managers.CommandManager;
import managers.DatabaseManager;
import server.Server;
import utility.Console;
import utility.StandardConsole;

public class ServerMain {
    public static void main(String[] args) {
        Console console = new StandardConsole();
        DatabaseManager databaseManager = new DatabaseManager();
        CollectionManager collectionManager = new CollectionManager(databaseManager);
        CommandManager commandManager = new CommandManager(console, collectionManager, databaseManager);
        Server server = new Server(5000, commandManager);
        server.run();
    }
}
package managers;

import models.HumanBeing;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CollectionManager {
    private final Map<Long, HumanBeing> collection;
    private final DatabaseManager dbManager;
    private final LocalDateTime initializationDate;

    public CollectionManager(DatabaseManager dbManager) {
        this.collection = new ConcurrentHashMap<>();
        this.dbManager = dbManager;
        this.initializationDate = LocalDateTime.now();
    }

    public List<HumanBeing> getCollection() {
        return dbManager.loadHumanBeings();
    }

    public LocalDateTime getInitializationDate() {
        return initializationDate;
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || userId == null) {
            return false;
        }
        if (dbManager.add(humanBeing, userId)) {
            collection.put(humanBeing.getId(), humanBeing);
            return true;
        }
        return false;
    }

    public boolean update(Long id, HumanBeing humanBeing, Integer userId) {
        return dbManager.updateHumanBeing(id, humanBeing, userId);
    }

    public boolean remove(Long id, Integer userId) {
        return dbManager.removeHumanBeing(id, userId);
    }

    public boolean clear(Integer userId) {
        return dbManager.clearHumanBeings(userId);
    }

    public Map<Long, HumanBeing> getCollectionMap() {
        return collection;
    }
}
package managers;

import commands.*;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashMap;
import java.util.Map;

public class CommandManager {
    private final Map<String, Command> commands = new HashMap<>();
    private final Console console;

    public CommandManager(Console console, CollectionManager collectionManager, DatabaseManager databaseManager) {
        this.console = console;
        commands.put("add", new Add(collectionManager));
        commands.put("update", new Update(console, collectionManager, databaseManager));
        commands.put("remove_head", new RemoveHead(collectionManager, console, databaseManager));
        commands.put("clear", new Clear(console, collectionManager, databaseManager));
        commands.put("info", new Info(console, collectionManager));
        commands.put("show", new Show(console, collectionManager));
        commands.put("login", new Login(databaseManager, console));
        commands.put("register", new Register(databaseManager, console));
        commands.put("exit", new Exit(console));
        commands.put("help", new Help(console, this));
        commands.put("filter_starts_with_name", new FilterStartsWithName(console, collectionManager));
        commands.put("print_unique_impact_speed", new PrintUniqueImpactSpeed(console, collectionManager));
        commands.put("count_less_than_impact_speed", new CountLessThanImpactSpeed(console, collectionManager));
        commands.put("execute_script", new ExecuteScript(console, this));
        commands.put("removebyid", new RemoveById(console, collectionManager));
    }

    public ExecutionResponse executeCommand(String commandName, HumanBeing humanBeing, Integer userId) {
        Command command = commands.get(commandName);
        if (command == null) {
            return new ExecutionResponse(false, "Команда '" + commandName + "' не найдена. Введите 'help' для списка команд.");
        }
        return command.execute(humanBeing, userId);
    }

    public Map<String, Command> getCommands() {
        return commands;
    }
}
package managers;

import models.*;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class DatabaseManager {
    private final String url = "jdbc:postgresql://localhost:5432/studs";
    private final String user = "s434931";
    private final String password = "250806";
    private Connection connection;
    private final Map<Long, HumanBeing> collection;

    public DatabaseManager() {
        this.collection = new ConcurrentHashMap<>();
        connect();
        loadHumanBeings();
    }

    private void connect() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
            }
            connection = DriverManager.getConnection(url, user, password);
            System.out.println("Подключение к базе данных установлено: " + url);
        } catch (SQLException e) {
            System.err.println("Ошибка подключения к базе данных: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void close() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                System.out.println("Соединение с базой данных закрыто");
            }
        } catch (SQLException e) {
            System.err.println("Ошибка при закрытии соединения с базой данных: " + e.getMessage());
        }
    }

    public Map<Long, HumanBeing> getCollection() {
        return collection;
    }

    public List<HumanBeing> loadHumanBeings() {
        collection.clear();
        List<HumanBeing> humans = new ArrayList<>();
        String query = "SELECT * FROM human_beings";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            while (rs.next()) {
                HumanBeing human = new HumanBeing();
                human.setId(rs.getLong("id"));
                human.setName(rs.getString("name"));
                human.setCoordinates(new Coordinates(
                        rs.getDouble("coordinate_x"),
                        rs.getFloat("coordinate_y")
                ));
                human.setCreationDate(rs.getTimestamp("creation_date").toLocalDateTime());
                human.setRealHero(rs.getBoolean("real_hero"));
                human.setHasToothpick(rs.getObject("has_toothpick") != null ? rs.getBoolean("has_toothpick") : null);
                human.setImpactSpeed(rs.getLong("impact_speed"));
                human.setWeaponType(WeaponType.valueOf(rs.getString("weapon_type")));
                human.setMood(rs.getString("mood"));
                human.setCar(new Car(rs.getString("car_name")));
                human.setUserId(rs.getInt("user_id"));
                collection.put(human.getId(), human);
                humans.add(human);
            }
            System.out.println("Коллекция загружена из базы данных: " + collection.size() + " элементов");
            return humans;
        } catch (SQLException e) {
            System.err.println("Ошибка загрузки коллекции: " + e.getMessage());
            return humans;
        }
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        String sql = "INSERT INTO human_beings (name, coordinate_x, coordinate_y, creation_date, impact_speed, real_hero, has_toothpick, weapon_type, mood, car_name, user_id) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setInt(11, userId);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    long id = rs.getLong(1);
                    humanBeing.setId(id);
                    return true;
                }
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка при добавлении элемента: " + e.getMessage());
            return false;
        }
    }

    public boolean removeHumanBeing(Long id, Integer userId) {
        if (id == null || userId == null) return false;
        String query = "DELETE FROM human_beings WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setLong(1, id);
            pstmt.setInt(2, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.remove(id);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка удаления: " + e.getMessage());
            return false;
        }
    }

    public boolean updateHumanBeing(Long id, HumanBeing humanBeing, Integer userId) {
        if (id == null || humanBeing == null || userId == null) return false;
        String query = "UPDATE human_beings SET name = ?, coordinate_x = ?, coordinate_y = ?, creation_date = ?, impact_speed = ?, real_hero = ?, has_toothpick = ?, weapon_type = ?, mood = ?, car_name = ? WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setLong(11, id);
            pstmt.setInt(12, userId);

            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                humanBeing.setId(id);
                humanBeing.setUserId(userId);
                collection.put(id, humanBeing);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка обновления: " + e.getMessage());
            return false;
        }
    }

    public boolean clearHumanBeings(Integer userId) {
        if (userId == null) return false;
        String query = "DELETE FROM human_beings WHERE user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setInt(1, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.entrySet().removeIf(entry -> entry.getValue().getUserId().equals(userId));
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка очистки: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    public Integer loginUser(String username, String password) {
        String query = "SELECT id, password FROM users WHERE username = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, username);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                String storedPassword = rs.getString("password");
                String hashedInputPassword = hashPassword(password);
                if (hashedInputPassword.equals(storedPassword)) {
                    return rs.getInt("id");
                }
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка авторизации: " + e.getMessage());
            return null;
        }
    }

    public Integer registerUser(String username, String password) {
        String query = "INSERT INTO users (username, password) VALUES (?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            String hashedPassword = hashPassword(password);
            System.out.println("Debug - Registration:");
            System.out.println("Username: " + username);
            System.out.println("Password: " + password);
            System.out.println("Hashed password: " + hashedPassword);
            pstmt.setString(1, username);
            pstmt.setString(2, hashedPassword);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt("id");
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка регистрации: " + e.getMessage());
            return null;
        }
    }

    private String hashPassword(String password) {
        int hash = password.hashCode();
        hash = hash * 31 + "SALT".hashCode();
        hash = hash * 31 + password.length();
        return String.format("%d", hash);
    }
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return String.format("(x=%.2f, y=%.2f)", x, y);
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return String.format("HumanBeing{id=%d, name='%s', coordinates=%s, creationDate=%s, realHero=%b, hasToothpick=%s, impactSpeed=%d, weaponType=%s, mood=%s, car=%s, userId=%d}",
                id, name, coordinates, creationDate, realHero, hasToothpick, impactSpeed, weaponType, mood, car, userId);
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package server;

import managers.CommandManager;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    private final int port;
    private final CommandManager commandManager;

    public Server(int port, CommandManager commandManager) {
        this.port = port;
        this.commandManager = commandManager;
    }

    public void run() {
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Сервер запущен на порту " + port);
            while (true) {
                try (Socket clientSocket = serverSocket.accept()) {
                    System.out.println("Клиент подключен: " + clientSocket.getInetAddress());
                    handleClient(clientSocket);
                } catch (Exception e) {
                    System.out.println("Ошибка обработки клиента: " + e.getMessage());
                    e.printStackTrace(); // ← это покажет реальную причину!
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка сервера: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleClient(Socket clientSocket) throws IOException {
        try (ObjectInputStream input = new ObjectInputStream(clientSocket.getInputStream());
             ObjectOutputStream output = new ObjectOutputStream(clientSocket.getOutputStream())) {

            while (!clientSocket.isClosed()) {
                try {
                    String commandName = (String) input.readObject();
                    Object argument = input.readObject();
                    Integer userId = (Integer) input.readObject();

                    System.out.println("Получен запрос: command=" + commandName + ", userId=" + userId);
                    if (argument != null) {
                        if (argument instanceof HumanBeing) {
                            System.out.println("Аргумент: " + ((HumanBeing) argument).getName());
                        } else if (argument instanceof Long) {
                            System.out.println("Аргумент: id=" + argument);
                        } else {
                            System.out.println("Аргумент: " + argument);
                        }
                    } else {
                        System.out.println("Аргумент: null");
                    }

                    HumanBeing humanBeing = null;
                    if (argument instanceof HumanBeing) {
                        humanBeing = (HumanBeing) argument;
                    } else if (commandName.equals("removebyid") && argument instanceof Long) {
                        humanBeing = new HumanBeing();
                        humanBeing.setId((Long) argument);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, humanBeing, userId);

                    output.writeObject(response);
                    output.flush();

                    if (commandName.equals("exit")) {
                        System.out.println("Клиент отключен: " + clientSocket.getInetAddress());
                        break;
                    }
                } catch (ClassNotFoundException e) {
                    System.err.println("Ошибка чтения данных: " + e.getMessage());
                    output.writeObject(new ExecutionResponse(false, "Ошибка чтения данных: " + e.getMessage()));
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка обработки клиента: " + e.getMessage());
            throw e;
        }
    }
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;

public class ExecutionResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private final boolean success;
    private final String message;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        // Name
        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        // Coordinate X
        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        // Coordinate Y
        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        // Устанавливаем координаты один раз после успешного ввода x и y
        humanBeing.setCoordinates(new Coordinates(x, y));

        // Real Hero
        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        // Has Toothpick
        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        // Impact Speed
        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        // Weapon Type
        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        // Mood
        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood.valueOf(moodInput.toUpperCase()); // Validate input
                humanBeing.setMood(moodInput);
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        // Car
        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        // Creation Date (set automatically)
        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;
import java.io.Serializable;

public class Request implements Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }

    @Override
    public String toString() {
        return "Request{commandName='" + commandName + "', argument=" + argument + ", userId=" + userId + "}";
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package main;

import models.Car;
import models.HumanBeing;
import models.Mood;
import models.WeaponType;
import utility.*;
import utility.Console;

import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

public class ClientMain {
    private static Integer userId = null;
    private static List<String> users = new ArrayList<>();

    public static void main(String[] args) {
        String host = "localhost";
        int port = 5000;
        Console console = new StandardConsole();

        try (Socket socket = new Socket(host, port);
             ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
             ObjectInputStream input = new ObjectInputStream(socket.getInputStream())) {

            console.println("Подключено к серверу: " + host + ":" + port);

            while (true) {
                console.println("Введите команду: ");
                String command = console.read().trim();
                Object argument = null;

                if (command.equals("exit")) {
                    output.writeObject(command);
                    output.writeObject(null);
                    output.writeObject(userId);
                    break;
                }

                String[] parts = command.split("\\s+", 2);
                String commandName = parts[0].toLowerCase();

                if (commandName.equals("delete_user")) {
                    if (userId == null) {
                        console.println("Ошибка: необходимо авторизоваться");
                        continue;
                    }
                    output.writeObject("get_users");
                    output.writeObject(null);
                    output.writeObject(userId);
                    output.flush();

                    ExecutionResponse response = (ExecutionResponse) input.readObject();
                    if (!response.isSuccess()) {
                        console.println("Ошибка при получении списка пользователей: " + response.getMessage());
                        continue;
                    }

                    String[] usersList = response.getMessage().split("\n");
                    users.clear();
                    for (String user : usersList) {
                        if (!user.trim().isEmpty()) {
                            users.add(user.trim());
                        }
                    }

                    if (users.isEmpty()) {
                        console.println("Список пользователей пуст");
                        continue;
                    }

                    console.println("Список пользователей:");
                    for (int i = 0; i < users.size(); i++) {
                        console.println((i + 1) + ". " + users.get(i));
                    }

                    console.println("Введите номер пользователя для удаления:");
                    String inputStr = console.read().trim();
                    int userNumber;
                    try {
                        userNumber = Integer.parseInt(inputStr);
                        if (userNumber < 1 || userNumber > users.size()) {
                            console.println("Ошибка: неверный номер пользователя");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректный номер");
                        continue;
                    }

                    String usernameToDelete = users.get(userNumber - 1);
                    console.println("Вы уверены, что хотите удалить пользователя " + usernameToDelete + "? (да/нет)");
                    String confirmation = console.read().trim().toLowerCase();
                    if (!confirmation.equals("да")) {
                        console.println("Удаление отменено");
                        continue;
                    }

                    users.remove(userNumber - 1);
                    console.println("Пользователь " + usernameToDelete + " успешно удален");
                    continue;
                }

                if (commandName.equals("register") || commandName.equals("login")) {
                    console.println("Введите имя пользователя (не пустое):");
                    String username = console.read().trim();
                    if (username.isEmpty()) {
                        console.println("Ошибка: имя пользователя не может быть пустым");
                        continue;
                    }

                    console.println("Введите пароль (не пустой):");
                    String password = console.read().trim();
                    if (password.isEmpty()) {
                        console.println("Ошибка: пароль не может быть пустым");
                        continue;
                    }

                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(username);
                    humanBeing.setCar(new Car(password));
                    argument = humanBeing;
                } else if (commandName.equals("execute_script")) {
                    console.println("Введите путь к файлу скрипта:");
                    String scriptPath = console.read().trim();
                    if (scriptPath.isEmpty()) {
                        console.println("Ошибка: путь к файлу не может быть пустым");
                        continue;
                    }
                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(scriptPath);
                    argument = humanBeing;
                } else if (commandName.equals("removebyid")) {
                    console.println("Введите id элемента для удаления (целое положительное число):");
                    String idInput = console.read().trim();
                    Long id;
                    try {
                        id = Long.parseLong(idInput);
                        if (id <= 0) {
                            console.println("Ошибка: id должен быть положительным числом");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректное целое число для id");
                        continue;
                    }
                    argument = id;
                } else {
                    if (userId == null) {
                        console.println("Ошибка: необходимо войти в систему (login) или зарегистрироваться (register)");
                        continue;
                    }

                    if (commandName.equals("add")) {
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("update")) {
                        console.println("Введите id элемента для обновления (целое положительное число):");
                        String idInput = console.read().trim();
                        Long id;
                        try {
                            id = Long.parseLong(idInput);
                            if (id <= 0) {
                                console.println("Ошибка: id должен быть положительным числом");
                                continue;
                            }
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число для id");
                            continue;
                        }
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            humanBeing.setId(id);
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("filter_starts_with_name")) {
                        console.println("Введите имя (не пустое):");
                        String name = console.read().trim();
                        if (name.isEmpty()) {
                            console.println("Ошибка: имя не может быть пустым");
                            continue;
                        }
                        HumanBeing humanBeing = new HumanBeing();
                        humanBeing.setName(name);
                        argument = humanBeing;
                    } else if (commandName.equals("count_less_than_impact_speed")) {
                        console.println("Введите impactSpeed (целое число):");
                        String impactSpeedInput = console.read().trim();
                        try {
                            long impactSpeed = Long.parseLong(impactSpeedInput);
                            HumanBeing humanBeing = new HumanBeing();
                            humanBeing.setImpactSpeed(impactSpeed);
                            argument = humanBeing;
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число");
                            continue;
                        }
                    }
                }

                output.writeObject(commandName);
                output.writeObject(argument);
                output.writeObject(userId);
                output.flush();

                ExecutionResponse response = (ExecutionResponse) input.readObject();
                console.println("Ответ сервера: " + response.getMessage());

                if (commandName.equals("execute_script")) {
                    if (response.isSuccess()) {
                        console.println("Результат выполнения скрипта:");
                        String message = response.getMessage();
                        if (message != null && !message.isEmpty()) {
                            String[] lines = message.split("\\r?\\n");
                            for (String line : lines) {
                                console.println(line);
                            }
                        } else {
                            console.println("Пустой результат от сервера");
                        }
                    } else {
                        console.println("Ошибка выполнения скрипта: " + response.getMessage());
                    }
                }

                if ((commandName.equals("login") || commandName.equals("register")) && response.isSuccess()) {
                    try {
                        userId = Integer.parseInt(response.getMessage());
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: некорректный userId от сервера");
                    }
                }
            }
        } catch (IOException | ClassNotFoundException e) {
            console.println("Ошибка клиента: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
package main.gui;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.stage.Stage;
import main.gui.controllers.MainWindowController;

import java.util.Locale;
import java.util.ResourceBundle;

public class MainApp extends Application {
    private static Locale locale = new Locale("ru", "RU");
    private static ResourceBundle bundle = ResourceBundle.getBundle("main.gui.locale.messages", locale);

    public static Locale getLocale() { return locale; }
    public static void setLocale(Locale l) {
        locale = l;
        bundle = ResourceBundle.getBundle("main.gui.locale.messages", locale);
    }
    public static ResourceBundle getBundle() { return bundle; }

    @Override
    public void start(Stage primaryStage) throws Exception {
        showAuthWindow();
    }

    public static void showAuthWindow() throws Exception {
        FXMLLoader loader = new FXMLLoader(MainApp.class.getResource("/main/gui/views/auth.fxml"), getBundle());
        Stage stage = new Stage();
        stage.setTitle(bundle.getString("auth.title"));
        stage.setScene(new Scene(loader.load()));
        stage.show();
    }

    public static void showMainWindow(NetworkClient client, Integer userId) throws Exception {
        FXMLLoader loader = new FXMLLoader(MainApp.class.getResource("/main/gui/views/main.fxml"), getBundle());
        Stage stage = new Stage();
        stage.setTitle(bundle.getString("main.title"));
        stage.setScene(new Scene(loader.load()));
        MainWindowController controller = loader.getController();
        controller.initSession(client, userId);
        stage.show();
    }
}
package main.gui;

import utility.ExecutionResponse;

import java.io.*;
import java.net.Socket;

public class NetworkClient implements Closeable {
    private Socket socket;
    private ObjectOutputStream output;
    private ObjectInputStream input;

    public boolean connect(String host, int port) {
        try {
            socket = new Socket(host, port);
            output = new ObjectOutputStream(socket.getOutputStream());
            input = new ObjectInputStream(socket.getInputStream());
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    public ExecutionResponse sendCommand(String command, Object argument, Integer userId) {
        try {
            output.writeObject(command);
            output.writeObject(argument);
            output.writeObject(userId);
            output.flush();
            return (ExecutionResponse) input.readObject();
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка клиента: " + e.getMessage());
        }
    }

    @Override
    public void close() throws IOException {
        if (output != null) output.close();
        if (input != null) input.close();
        if (socket != null) socket.close();
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.MainApp;
import main.gui.NetworkClient;
import models.Car;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.IOException;
import java.util.Locale;

public class AuthController {
    @FXML private TextField usernameField;
    @FXML private PasswordField passwordField;
    @FXML private Button loginButton;
    @FXML private Button registerButton;
    @FXML private ComboBox<String> languageBox;
    @FXML private Label messageLabel;

    private NetworkClient networkClient;
    private Integer userId;

    private int lastLanguageIndex = -1;

    @FXML
    private void initialize() {
        languageBox.getItems().setAll("Русский", "Македонский", "Latviešu", "Español (Colombia)");
        Locale current = MainApp.getLocale();
        int idx = 0;
        if (current.getLanguage().equals("ru")) idx = 0;
        else if (current.getLanguage().equals("mk")) idx = 1;
        else if (current.getLanguage().equals("lv")) idx = 2;
        else if (current.getLanguage().equals("es")) idx = 3;
        languageBox.getSelectionModel().select(idx);
        lastLanguageIndex = idx;

        languageBox.getSelectionModel().selectedIndexProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            if (newVal.intValue() == lastLanguageIndex) return; // если язык не менялся — не перезагружаем
            lastLanguageIndex = newVal.intValue();
            switch (newVal.intValue()) {
                case 0:
                    MainApp.setLocale(new Locale("ru", "RU")); break;
                case 1:
                    MainApp.setLocale(new Locale("mk", "MK")); break;
                case 2:
                    MainApp.setLocale(new Locale("lv", "LV")); break;
                case 3:
                    MainApp.setLocale(new Locale("es", "CO")); break;
            }
            java.util.ResourceBundle.clearCache();
            reload();
        });
    }

    private void reload() {
        try {
            Stage stage = (Stage) usernameField.getScene().getWindow();
            stage.close();
            MainApp.showAuthWindow();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @FXML
    private void handleLogin(javafx.event.ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.empty"));
            return;
        }

        if (networkClient != null) {
            try { networkClient.close(); } catch (IOException ignored) {}
        }
        networkClient = new NetworkClient();
        if (!networkClient.connect("localhost", 5000)) {
            messageLabel.setText("Ошибка соединения с сервером");
            return;
        }
        HumanBeing user = new HumanBeing();
        user.setName(username);
        user.setCar(new Car(password));
        ExecutionResponse response = networkClient.sendCommand("login", user, null);
        if (response.isSuccess()) {
            try {
                userId = Integer.parseInt(response.getMessage());
                messageLabel.setText(MainApp.getBundle().getString("auth.login.success"));
                try {
                    MainApp.showMainWindow(networkClient, userId);
                    Stage stage = (Stage) loginButton.getScene().getWindow();
                    stage.close();
                } catch (Exception e) {
                    e.printStackTrace();
                    messageLabel.setText("Ошибка открытия главного окна: " + e.getMessage());
                }
            } catch (NumberFormatException e) {
                messageLabel.setText("Некорректный userId от сервера");
                try { networkClient.close(); } catch (IOException ignored) {}
            }
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.fail") + " " + response.getMessage());
            try { networkClient.close(); } catch (IOException ignored) {}
        }
    }

    @FXML
    private void handleRegister(javafx.event.ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.empty"));
            return;
        }

        if (networkClient != null) {
            try { networkClient.close(); } catch (IOException ignored) {}
        }
        networkClient = new NetworkClient();
        if (!networkClient.connect("localhost", 5000)) {
            messageLabel.setText("Ошибка соединения с сервером");
            return;
        }
        HumanBeing user = new HumanBeing();
        user.setName(username);
        user.setCar(new Car(password));
        ExecutionResponse response = networkClient.sendCommand("register", user, null);
        if (response.isSuccess()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.success"));
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.fail") + " " + response.getMessage());
            try { networkClient.close(); } catch (IOException ignored) {}
        }
    }

    public NetworkClient getNetworkClient() {
        return networkClient;
    }
    public Integer getUserId() {
        return userId;
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;

public class MainController {
    @FXML private Label userLabel;
    @FXML private TableView<?> tableView; // замените ? на вашу модель
    @FXML private Canvas canvas;

    @FXML
    private void initialize() {
        userLabel.setText("User: ...");
        // Настройка TableView, загрузка данных с сервера
    }

    @FXML
    private void handleCanvasClick(MouseEvent event) {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        // TODO: обработка клика, выделение объекта, вывод информации
    }

    // Добавьте методы для фильтрации, сортировки, обновления таблицы, работы с графикой и т.д.
}
package main.gui.controllers;

import javafx.collections.FXCollections;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.MainApp;
import main.gui.NetworkClient;
import utility.ExecutionResponse;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

public class MainWindowController {
    @FXML private ComboBox<String> languageBox;
    @FXML private ListView<String> commandListView;
    @FXML private Label commandTitle;
    @FXML private TextArea commandOutput;
    @FXML private Button executeButton;
    @FXML private TextField argumentField;
    @FXML private Button registerButton;
    @FXML private Button exitButton;

    private NetworkClient networkClient;
    private Integer userId;

    private final List<String> commands = Arrays.asList(
            "add", "update", "remove_head", "clear", "info", "show",
            "help", "filter_starts_with_name", "print_unique_impact_speed",
            "count_less_than_impact_speed", "execute_script", "removebyid"
    );

    private int lastLanguageIndex = -1;

    public void initSession(NetworkClient networkClient, Integer userId) {
        this.networkClient = networkClient;
        this.userId = userId;
        List<String> visibleCommands = commands.stream()
                .filter(cmd -> !cmd.equals("login") && !cmd.equals("register"))
                .collect(Collectors.toList());
        commandListView.setItems(FXCollections.observableArrayList(visibleCommands));
    }

    @FXML
    private void initialize() {
        languageBox.getItems().setAll("Русский", "Македонский", "Latviešu", "Español (Colombia)");
        Locale current = MainApp.getLocale();
        int idx = 0;
        if (current.getLanguage().equals("ru")) idx = 0;
        else if (current.getLanguage().equals("mk")) idx = 1;
        else if (current.getLanguage().equals("lv")) idx = 2;
        else if (current.getLanguage().equals("es")) idx = 3;
        languageBox.getSelectionModel().select(idx);
        lastLanguageIndex = idx;

        languageBox.getSelectionModel().selectedIndexProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            if (newVal.intValue() == lastLanguageIndex) return;
            lastLanguageIndex = newVal.intValue();
            switch (newVal.intValue()) {
                case 0:
                    MainApp.setLocale(new Locale("ru", "RU")); break;
                case 1:
                    MainApp.setLocale(new Locale("mk", "MK")); break;
                case 2:
                    MainApp.setLocale(new Locale("lv", "LV")); break;
                case 3:
                    MainApp.setLocale(new Locale("es", "CO")); break;
            }
            java.util.ResourceBundle.clearCache();
            reload();
        });

        commandListView.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            commandTitle.setText(newVal == null ? "" : newVal);
            commandOutput.clear();
            argumentField.clear();
        });
        commandListView.getSelectionModel().selectFirst();

        executeButton.setOnAction(event -> executeSelectedCommand());
        argumentField.setOnAction(event -> executeSelectedCommand());
        registerButton.setOnAction(event -> goToRegister());
        exitButton.setOnAction(event -> exitApp());
    }

    private void executeSelectedCommand() {
        String command = commandListView.getSelectionModel().getSelectedItem();
        if (command == null) return;
        String arg = argumentField.getText();

        Object argument = null;
        try {
            if (!arg.isEmpty()) {
                if (command.equals("removebyid") || command.equals("update") || command.equals("count_less_than_impact_speed")) {
                    argument = Long.parseLong(arg);
                } else {
                    argument = arg;
                }
            }
        } catch (Exception e) {
            commandOutput.setText("Ошибка ввода аргумента: " + e.getMessage());
            return;
        }

        if ("help".equals(command)) {
            ExecutionResponse response = networkClient.sendCommand(command, argument, userId);
            String filtered = Arrays.stream(response.getMessage().split("\\r?\\n"))
                    .filter(line -> !line.trim().startsWith("login") && !line.trim().startsWith("register"))
                    .collect(Collectors.joining("\n"));
            commandOutput.setText(filtered);
        } else {
            ExecutionResponse response = networkClient.sendCommand(command, argument, userId);
            commandOutput.setText(response.getMessage());
        }
    }

    private void goToRegister() {
        try {
            if (networkClient != null) {
                networkClient.close();
            }
        } catch (IOException ignored) {}
        try {
            Stage stage = (Stage) registerButton.getScene().getWindow();
            stage.close();
            MainApp.showAuthWindow();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void exitApp() {
        try {
            networkClient.sendCommand("exit", null, userId);
            networkClient.close();
        } catch (IOException ignored) {}
        Stage stage = (Stage) exitButton.getScene().getWindow();
        stage.close();
    }

    private void reload() {
        try {
            Stage stage = (Stage) languageBox.getScene().getWindow();
            NetworkClient oldClient = this.networkClient;
            Integer oldUserId = this.userId;
            stage.close();
            MainApp.showMainWindow(oldClient, oldUserId);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return "HumanBeing{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", coordinates=" + coordinates +
                ", creationDate=" + creationDate +
                ", realHero=" + realHero +
                ", hasToothpick=" + hasToothpick +
                ", impactSpeed=" + impactSpeed +
                ", weaponType=" + weaponType +
                ", mood=" + mood +
                ", car=" + car +
                ", userId=" + userId +
                '}';
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;

public class ExecutionResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private final boolean success;
    private final String message;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        humanBeing.setCoordinates(new Coordinates(x, y));

        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood mood = Mood.valueOf(moodInput.toUpperCase());
                humanBeing.setMood(mood.toString());
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;

public class Request implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package commands;

import models.HumanBeing;
import utility.ExecutionResponse;
import managers.CollectionManager;

public class Add extends Command {
    private final CollectionManager collectionManager;

    public Add(CollectionManager collectionManager) {
        super("add", "добавить новый элемент в коллекцию");
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null) {
            return new ExecutionResponse(false, "Ошибка: объект не может быть null");
        }
        humanBeing.setUserId(userId);
        boolean success = collectionManager.add(humanBeing, userId);
        if (success) {
            return new ExecutionResponse(true, "Элемент успешно добавлен с id: " + humanBeing.getId());
        } else {
            return new ExecutionResponse(false, "Не удалось добавить элемент");
        }
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Clear extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Clear(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("clear", "очистить коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: clear, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        boolean success = collectionManager.clear(userId);
        if (success) {
            return new ExecutionResponse(true, "Коллекция успешно очищена для пользователя с ID " + userId);
        } else {
            return new ExecutionResponse(false, "Ошибка при очистке коллекции");
        }
    }
}
package commands;

import models.HumanBeing;
import utility.ExecutionResponse;

public abstract class Command {
    protected String name;
    protected String description;

    public Command(String name, String description) {
        this.name = name;
        this.description = description;
    }

    public abstract ExecutionResponse execute(HumanBeing argument, Integer userId);

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class CountLessThanImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public CountLessThanImpactSpeed(Console console, CollectionManager collectionManager) {
        super("count_less_than_impact_speed", "вывести количество элементов, значение поля impactSpeed которых меньше заданного");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: count_less_than_impact_speed, userId: " + userId);
        if (argument == null || argument.getImpactSpeed() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать значение impactSpeed");
        }

        long threshold = argument.getImpactSpeed();
        long count = collectionManager.getCollection().stream()
                .filter(h -> h.getUserId().equals(userId))
                .filter(h -> h.getImpactSpeed() < threshold)
                .count();

        return new ExecutionResponse(true, "Количество элементов с impactSpeed меньше " + threshold + ": " + count);
    }
}
package commands;

import models.HumanBeing;
import models.Coordinates;
import models.Car;
import models.WeaponType;
import models.Mood;
import utility.Console;
import utility.ExecutionResponse;
import managers.CommandManager;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;

public class ExecuteScript extends Command {
    private final Console console;
    private final CommandManager commandManager;
    private final Set<String> executedFiles = new HashSet<>();
    private final List<String> inputLines = new ArrayList<>();

    public ExecuteScript(Console console, CommandManager commandManager) {
        super("execute_script", "исполнить скрипт из файла");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || humanBeing.getName() == null || humanBeing.getName().trim().isEmpty()) {
            return new ExecutionResponse(false, "Требуется путь к файлу скрипта");
        }

        String scriptPath = humanBeing.getName().trim();

        try {
            String absolutePath = Paths.get(scriptPath).toAbsolutePath().toString();

            if (executedFiles.contains(absolutePath)) {
                return new ExecutionResponse(false, "Обнаружена рекурсия: файл " + scriptPath + " уже выполняется");
            }

            executedFiles.add(absolutePath);
            StringBuilder scriptOutput = new StringBuilder();

            try (BufferedReader reader = new BufferedReader(new FileReader(absolutePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith("#")) continue;

                    String[] parts = line.split("\\s+", 2);
                    String commandName = parts[0].toLowerCase();
                    HumanBeing commandHumanBeing = new HumanBeing();

                    if (commandName.equals("execute_script")) {
                        commandHumanBeing.setName(parts.length > 1 ? parts[1] : "");
                    } else if (commandName.equals("add") || commandName.equals("update")) {
                        // Читаем следующие 9 строк для команды add/update
                        inputLines.clear();
                        for (int i = 0; i < 9; i++) {
                            String nextLine = reader.readLine();
                            if (nextLine == null) {
                                return new ExecutionResponse(false, "Неожиданный конец файла при чтении параметров команды " + commandName);
                            }
                            nextLine = nextLine.trim();
                            if (nextLine.isEmpty()) {
                                i--; // Пропускаем пустые строки
                                continue;
                            }
                            inputLines.add(nextLine);
                        }
                        // Устанавливаем параметры в объект HumanBeing в правильном порядке
                        if (inputLines.size() >= 1) commandHumanBeing.setName(inputLines.get(0));
                        if (inputLines.size() >= 3) {
                            try {
                                double x = Double.parseDouble(inputLines.get(1));
                                float y = Float.parseFloat(inputLines.get(2));
                                commandHumanBeing.setCoordinates(new Coordinates(x, y));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении координат: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 4) commandHumanBeing.setRealHero(Boolean.parseBoolean(inputLines.get(3)));
                        if (inputLines.size() >= 5) commandHumanBeing.setHasToothpick(Boolean.parseBoolean(inputLines.get(4)));
                        if (inputLines.size() >= 6) {
                            try {
                                commandHumanBeing.setImpactSpeed(Long.parseLong(inputLines.get(5)));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении impactSpeed: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 7) {
                            try {
                                commandHumanBeing.setWeaponType(WeaponType.valueOf(inputLines.get(6)));
                            } catch (IllegalArgumentException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении weaponType: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 8) commandHumanBeing.setMood(inputLines.get(7));
                        if (inputLines.size() >= 9) {
                            String carName = inputLines.get(8);
                            commandHumanBeing.setCar(new Car(carName));
                        }
                        // Устанавливаем дату создания для команды add
                        if (commandName.equals("add")) {
                            commandHumanBeing.setCreationDate(LocalDateTime.now());
                        }
                    } else if (commandName.equals("removebyid")) {
                        if (parts.length > 1) {
                            try {
                                commandHumanBeing.setId(Long.parseLong(parts[1]));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка: ID должен быть числом");
                            }
                        }
                    } else if (parts.length > 1) {
                        commandHumanBeing.setName(parts[1]);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, commandHumanBeing, userId);
                    scriptOutput.append(response.getMessage()).append("\n");
                }
            } finally {
                executedFiles.remove(absolutePath);
            }

            return new ExecutionResponse(true, scriptOutput.toString().trim());
        } catch (IOException e) {
            return new ExecutionResponse(false, "Ошибка при чтении файла: " + e.getMessage());
        }
    }
}
package commands;

import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Exit extends Command {
    private final Console console;

    public Exit(Console console) {
        super("exit", "завершить работу клиента");
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Завершение работы клиента");
        return new ExecutionResponse(true, "Клиент отключен");
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class FilterStartsWithName extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public FilterStartsWithName(Console console, CollectionManager collectionManager) {
        super("filter_starts_with_name", "вывести элементы, значение поля name которых начинается с заданной подстроки");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: filter_starts_with_name, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }
        if (argument == null || argument.getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать подстроку для поля name");
        }

        String prefix = argument.getName();
        console.println("Ищем элементы с именем, начинающимся с: " + prefix);
        
        StringBuilder response = new StringBuilder("Элементы с именем, начинающимся с \"" + prefix + "\":\n");
        boolean found = false;
        int totalElements = 0;
        int matchingElements = 0;

        for (HumanBeing human : collectionManager.getCollection()) {
            totalElements++;
            console.println("Проверяем элемент: " + human.getName() + " (userId: " + human.getUserId() + ")");
            if (human.getName().startsWith(prefix) && human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                matchingElements++;
            }
        }

        console.println("Всего элементов в коллекции: " + totalElements);
        console.println("Найдено совпадающих элементов: " + matchingElements);

        if (!found) {
            response.append("Элементы не найдены.");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CommandManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.Locale;
import java.util.ResourceBundle;

public class Help extends Command {
    private final Console console;
    private final CommandManager commandManager;

    public Help(Console console, CommandManager commandManager) {
        super("help", "вывести справку по доступным командам");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        // Читаем язык из argument.getName()
        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        Locale locale = new Locale(lang);
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", locale);
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        StringBuilder response = new StringBuilder(
                bundle.containsKey("help.title")
                        ? bundle.getString("help.title") + "\n"
                        : "Доступные команды:\n"
        );

        for (var entry : commandManager.getCommands().entrySet()) {
            String name = entry.getKey();
            Command command = entry.getValue();
            String key = "help." + name;
            String description = bundle.containsKey(key)
                    ? bundle.getString(key)
                    : command.getDescription();
            response.append(name).append(": ").append(description).append("\n");
        }
        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;

public class Info extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Info(Console console, CollectionManager collectionManager) {
        super("info", "вывести информацию о коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: info, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        int totalElements = collection.size();
        int userElements = 0;

        for (HumanBeing human : collection) {
            if (human.getUserId().equals(userId)) {
                userElements++;
            }
        }

        StringBuilder response = new StringBuilder();
        response.append("Тип коллекции: ").append(collection.getClass().getSimpleName()).append("\n");
        response.append("Дата инициализации: ").append(collectionManager.getInitializationDate()).append("\n");
        response.append("Всего элементов в коллекции: ").append(totalElements).append("\n");
        response.append("Ваших элементов в коллекции: ").append(userElements);

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Login extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Login(DatabaseManager dbManager, Console console) {
        super("login", "авторизоваться с существующим пользователем");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: login, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: " + "необходимо указать имя пользователя и пароль");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка авторизации: username=" + username);
        Integer resultId = dbManager.loginUser(username, password);
        if (resultId != null) {
            return new ExecutionResponse(true, String.valueOf(resultId));
        } else {
            return new ExecutionResponse(false, "Ошибка авторизации: неверный username или password");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashSet;
import java.util.Set;

public class PrintUniqueImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public PrintUniqueImpactSpeed(Console console, CollectionManager collectionManager) {
        super("print_unique_impact_speed", "вывести уникальные значения поля impactSpeed");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: print_unique_impact_speed, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        Set<Long> uniqueSpeeds = new HashSet<>();
        for (HumanBeing human : collectionManager.getCollection()) {
            if (human.getUserId().equals(userId)) {
                uniqueSpeeds.add(human.getImpactSpeed());
            }
        }

        if (uniqueSpeeds.isEmpty()) {
            return new ExecutionResponse(true, "У вас нет элементов в коллекции.");
        }

        StringBuilder response = new StringBuilder("Уникальные значения impactSpeed:\n");
        for (Long speed : uniqueSpeeds) {
            response.append(speed).append("\n");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Register extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Register(DatabaseManager dbManager, Console console) {
        super("register", "зарегистрировать нового пользователя");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: register, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать username и password");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка регистрации: username=" + username);

        Integer newUserId = dbManager.registerUser(username, password);
        if (newUserId != null) {
            return new ExecutionResponse(true, String.valueOf(newUserId));
        } else {
            return new ExecutionResponse(false, "Ошибка регистрации: пользователь уже существует или неверные данные");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class RemoveById extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveById(Console console, CollectionManager collectionManager) {
        super("removebyid", "удалить элемент из коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: removebyid, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }
        if (argument == null || argument.getId() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать id для удаления");
        }

        Long id = argument.getId();
        // Debug: Print collection contents
        console.println("Содержимое коллекции перед удалением id=" + id + ":");
        for (Long key : collectionManager.getCollectionMap().keySet()) {
            HumanBeing hb = collectionManager.getCollectionMap().get(key);
            console.println("id=" + hb.getId() + ", userId=" + hb.getUserId());
        }

        HumanBeing humanBeing = collectionManager.getCollectionMap().get(id);
        if (humanBeing == null) {
            console.println("Элемент с id " + id + " не найден в коллекции");
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " не существует в коллекции");
        }
        if (!humanBeing.getUserId().equals(userId)) {
            console.println("Элемент с id " + id + " принадлежит userId=" + humanBeing.getUserId());
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " принадлежит другому пользователю");
        }

        boolean success = collectionManager.remove(id, userId);
        if (success) {
            console.println("Элемент с id " + id + " успешно удален");
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно удален");
        } else {
            console.println("Ошибка удаления id=" + id + " из базы данных");
            return new ExecutionResponse(false, "Ошибка при удалении элемента с id " + id + ": не удалось удалить из базы данных");
        }
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;

public class RemoveHead extends Command {
    private final CollectionManager collectionManager;
    private final DatabaseManager databaseManager;
    private final Console console;

    public RemoveHead(CollectionManager collection, Console console, DatabaseManager databaseManager) {
        super("remove_head", "вывести и удалить первый элемент коллекции");
        this.collectionManager = collection;
        this.databaseManager = databaseManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: remove_head, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        if (collection.isEmpty()) {
            return new ExecutionResponse(false, "Коллекция пуста");
        }

        HumanBeing head = collection.stream()
                .filter(h -> h.getUserId().equals(userId))
                .findFirst()
                .orElse(null);

        if (head == null) {
            return new ExecutionResponse(false, "Нет элементов, принадлежащих пользователю с ID " + userId);
        }

        boolean success = collectionManager.remove(head.getId(), userId);
        if (success) {
            return new ExecutionResponse(true, "Первый элемент: " + head.toString() + "\nЭлемент успешно удален");
        } else {
            return new ExecutionResponse(false, "Ошибка при удалении первого элемента");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import java.util.List;

public class Show extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Show(Console console, CollectionManager collectionManager) {
        super("show", "вывести все элементы коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: show, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        StringBuilder response = new StringBuilder("Элементы коллекции:\n");
        
        List<HumanBeing> collection = collectionManager.getCollection();
        boolean found = false;
        int totalElements = 0;
        int userElements = 0;

        for (HumanBeing human : collection) {
            totalElements++;
            if (human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                userElements++;
            }
        }

        console.println("Всего элементов в коллекции: " + totalElements);
        console.println("Ваших элементов: " + userElements);

        if (!found) {
            response.append("У вас нет элементов в коллекции.");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Update extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Update(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("update", "обновить элемент коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        console.println("Выполняется команда: update, userId: " + userId);
        
        if (humanBeing == null) {
            return new ExecutionResponse(false, "Ошибка: объект HumanBeing не предоставлен");
        }
        
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        Long id = humanBeing.getId();
        if (id == null) {
            return new ExecutionResponse(false, "Ошибка: id не указан");
        }
        
        if (id <= 0) {
            return new ExecutionResponse(false, "Ошибка: id должен быть положительным числом");
        }

        // Check if the element exists and belongs to the user
        HumanBeing existingHuman = collectionManager.getCollectionMap().get(id);
        if (existingHuman == null) {
            return new ExecutionResponse(false, "Ошибка: элемент с указанным id не найден");
        }

        if (!existingHuman.getUserId().equals(userId)) {
            return new ExecutionResponse(false, "Ошибка: вы не можете изменить элемент, созданный другим пользователем");
        }

        // Update the element
        boolean success = collectionManager.update(id, humanBeing, userId);
        if (success) {
            return new ExecutionResponse(true, "Элемент успешно обновлен");
        } else {
            return new ExecutionResponse(false, "Ошибка при обновлении элемента");
        }
    }
}
package main;

import managers.CollectionManager;
import managers.CommandManager;
import managers.DatabaseManager;
import server.Server;
import utility.Console;
import utility.StandardConsole;

public class ServerMain {
    public static void main(String[] args) {
        Console console = new StandardConsole();
        DatabaseManager databaseManager = new DatabaseManager();
        CollectionManager collectionManager = new CollectionManager(databaseManager);
        CommandManager commandManager = new CommandManager(console, collectionManager, databaseManager);
        Server server = new Server(5000, commandManager);
        server.run();
    }
}
package managers;

import models.HumanBeing;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CollectionManager {
    private final Map<Long, HumanBeing> collection;
    private final DatabaseManager dbManager;
    private final LocalDateTime initializationDate;

    public CollectionManager(DatabaseManager dbManager) {
        this.collection = new ConcurrentHashMap<>();
        this.dbManager = dbManager;
        this.initializationDate = LocalDateTime.now();
    }

    public List<HumanBeing> getCollection() {
        return dbManager.loadHumanBeings();
    }

    public LocalDateTime getInitializationDate() {
        return initializationDate;
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || userId == null) {
            return false;
        }
        if (dbManager.add(humanBeing, userId)) {
            collection.put(humanBeing.getId(), humanBeing);
            return true;
        }
        return false;
    }

    public boolean update(Long id, HumanBeing humanBeing, Integer userId) {
        return dbManager.updateHumanBeing(id, humanBeing, userId);
    }

    public boolean remove(Long id, Integer userId) {
        return dbManager.removeHumanBeing(id, userId);
    }

    public boolean clear(Integer userId) {
        return dbManager.clearHumanBeings(userId);
    }

    public Map<Long, HumanBeing> getCollectionMap() {
        return collection;
    }
}
package managers;

import commands.*;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashMap;
import java.util.Map;

public class CommandManager {
    private final Map<String, Command> commands = new HashMap<>();
    private final Console console;

    public CommandManager(Console console, CollectionManager collectionManager, DatabaseManager databaseManager) {
        this.console = console;
        commands.put("add", new Add(collectionManager));
        commands.put("update", new Update(console, collectionManager, databaseManager));
        commands.put("remove_head", new RemoveHead(collectionManager, console, databaseManager));
        commands.put("clear", new Clear(console, collectionManager, databaseManager));
        commands.put("info", new Info(console, collectionManager));
        commands.put("show", new Show(console, collectionManager));
        commands.put("login", new Login(databaseManager, console));
        commands.put("register", new Register(databaseManager, console));
        commands.put("exit", new Exit(console));
        commands.put("help", new Help(console, this));
        commands.put("filter_starts_with_name", new FilterStartsWithName(console, collectionManager));
        commands.put("print_unique_impact_speed", new PrintUniqueImpactSpeed(console, collectionManager));
        commands.put("count_less_than_impact_speed", new CountLessThanImpactSpeed(console, collectionManager));
        commands.put("execute_script", new ExecuteScript(console, this));
        commands.put("removebyid", new RemoveById(console, collectionManager));
    }

    public ExecutionResponse executeCommand(String commandName, HumanBeing humanBeing, Integer userId) {
        Command command = commands.get(commandName);
        if (command == null) {
            return new ExecutionResponse(false, "Команда '" + commandName + "' не найдена. Введите 'help' для списка команд.");
        }
        return command.execute(humanBeing, userId);
    }

    public Map<String, Command> getCommands() {
        return commands;
    }
}
package managers;

import models.*;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class DatabaseManager {
    private final String url = "jdbc:postgresql://localhost:5432/studs";
    private final String user = "s434931";
    private final String password = "250806";
    private Connection connection;
    private final Map<Long, HumanBeing> collection;

    public DatabaseManager() {
        this.collection = new ConcurrentHashMap<>();
        connect();
        loadHumanBeings();
    }

    private void connect() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
            }
            connection = DriverManager.getConnection(url, user, password);
            System.out.println("Подключение к базе данных установлено: " + url);
        } catch (SQLException e) {
            System.err.println("Ошибка подключения к базе данных: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void close() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                System.out.println("Соединение с базой данных закрыто");
            }
        } catch (SQLException e) {
            System.err.println("Ошибка при закрытии соединения с базой данных: " + e.getMessage());
        }
    }

    public Map<Long, HumanBeing> getCollection() {
        return collection;
    }

    public List<HumanBeing> loadHumanBeings() {
        collection.clear();
        List<HumanBeing> humans = new ArrayList<>();
        String query = "SELECT * FROM human_beings";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            while (rs.next()) {
                HumanBeing human = new HumanBeing();
                human.setId(rs.getLong("id"));
                human.setName(rs.getString("name"));
                human.setCoordinates(new Coordinates(
                        rs.getDouble("coordinate_x"),
                        rs.getFloat("coordinate_y")
                ));
                human.setCreationDate(rs.getTimestamp("creation_date").toLocalDateTime());
                human.setRealHero(rs.getBoolean("real_hero"));
                human.setHasToothpick(rs.getObject("has_toothpick") != null ? rs.getBoolean("has_toothpick") : null);
                human.setImpactSpeed(rs.getLong("impact_speed"));
                human.setWeaponType(WeaponType.valueOf(rs.getString("weapon_type")));
                human.setMood(rs.getString("mood"));
                human.setCar(new Car(rs.getString("car_name")));
                human.setUserId(rs.getInt("user_id"));
                collection.put(human.getId(), human);
                humans.add(human);
            }
            System.out.println("Коллекция загружена из базы данных: " + collection.size() + " элементов");
            return humans;
        } catch (SQLException e) {
            System.err.println("Ошибка загрузки коллекции: " + e.getMessage());
            return humans;
        }
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        String sql = "INSERT INTO human_beings (name, coordinate_x, coordinate_y, creation_date, impact_speed, real_hero, has_toothpick, weapon_type, mood, car_name, user_id) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setInt(11, userId);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    long id = rs.getLong(1);
                    humanBeing.setId(id);
                    return true;
                }
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка при добавлении элемента: " + e.getMessage());
            return false;
        }
    }

    public boolean removeHumanBeing(Long id, Integer userId) {
        if (id == null || userId == null) return false;
        String query = "DELETE FROM human_beings WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setLong(1, id);
            pstmt.setInt(2, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.remove(id);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка удаления: " + e.getMessage());
            return false;
        }
    }

    public boolean updateHumanBeing(Long id, HumanBeing humanBeing, Integer userId) {
        if (id == null || humanBeing == null || userId == null) return false;
        String query = "UPDATE human_beings SET name = ?, coordinate_x = ?, coordinate_y = ?, creation_date = ?, impact_speed = ?, real_hero = ?, has_toothpick = ?, weapon_type = ?, mood = ?, car_name = ? WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setLong(11, id);
            pstmt.setInt(12, userId);

            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                humanBeing.setId(id);
                humanBeing.setUserId(userId);
                collection.put(id, humanBeing);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка обновления: " + e.getMessage());
            return false;
        }
    }

    public boolean clearHumanBeings(Integer userId) {
        if (userId == null) return false;
        String query = "DELETE FROM human_beings WHERE user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setInt(1, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.entrySet().removeIf(entry -> entry.getValue().getUserId().equals(userId));
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка очистки: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    public Integer loginUser(String username, String password) {
        String query = "SELECT id, password FROM users WHERE username = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, username);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                String storedPassword = rs.getString("password");
                String hashedInputPassword = hashPassword(password);
                if (hashedInputPassword.equals(storedPassword)) {
                    return rs.getInt("id");
                }
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка авторизации: " + e.getMessage());
            return null;
        }
    }

    public Integer registerUser(String username, String password) {
        String query = "INSERT INTO users (username, password) VALUES (?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            String hashedPassword = hashPassword(password);
            System.out.println("Debug - Registration:");
            System.out.println("Username: " + username);
            System.out.println("Password: " + password);
            System.out.println("Hashed password: " + hashedPassword);
            pstmt.setString(1, username);
            pstmt.setString(2, hashedPassword);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt("id");
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка регистрации: " + e.getMessage());
            return null;
        }
    }

    private String hashPassword(String password) {
        int hash = password.hashCode();
        hash = hash * 31 + "SALT".hashCode();
        hash = hash * 31 + password.length();
        return String.format("%d", hash);
    }
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return String.format("(x=%.2f, y=%.2f)", x, y);
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return String.format("HumanBeing{id=%d, name='%s', coordinates=%s, creationDate=%s, realHero=%b, hasToothpick=%s, impactSpeed=%d, weaponType=%s, mood=%s, car=%s, userId=%d}",
                id, name, coordinates, creationDate, realHero, hasToothpick, impactSpeed, weaponType, mood, car, userId);
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package server;

import managers.CommandManager;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;

public class Server {
    private final int port;
    private final CommandManager commandManager;

    public Server(int port, CommandManager commandManager) {
        this.port = port;
        this.commandManager = commandManager;
    }

    public void run() {
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Сервер запущен на порту " + port);
            while (true) {
                try {
                    Socket clientSocket = serverSocket.accept();
                    System.out.println("Клиент подключен: " + clientSocket.getInetAddress());
                    handleClient(clientSocket);
                } catch (IOException e) {
                    System.err.println("Ошибка обработки клиента: " + e.getMessage());
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка сервера: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleClient(Socket clientSocket) {
        try (
                ObjectInputStream input = new ObjectInputStream(clientSocket.getInputStream());
                ObjectOutputStream output = new ObjectOutputStream(clientSocket.getOutputStream())
        ) {
            while (!clientSocket.isClosed()) {
                try {
                    String commandName = (String) input.readObject();
                    Object argument = input.readObject();
                    Integer userId = (Integer) input.readObject();

                    System.out.println("Получен запрос: command=" + commandName + ", userId=" + userId);
                    if (argument != null) {
                        if (argument instanceof HumanBeing) {
                            System.out.println("Аргумент: " + ((HumanBeing) argument).getName());
                        } else if (argument instanceof Long) {
                            System.out.println("Аргумент: id=" + argument);
                        } else {
                            System.out.println("Аргумент: " + argument);
                        }
                    } else {
                        System.out.println("Аргумент: null");
                    }

                    HumanBeing humanBeing = null;
                    if (argument instanceof HumanBeing) {
                        humanBeing = (HumanBeing) argument;
                    } else if ("removebyid".equals(commandName) && argument instanceof Long) {
                        humanBeing = new HumanBeing();
                        humanBeing.setId((Long) argument);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, humanBeing, userId);

                    output.writeObject(response);
                    output.flush();

                    if ("exit".equals(commandName)) {
                        System.out.println("Клиент отключен по команде exit: " + clientSocket.getInetAddress());
                        break;
                    }
                } catch (EOFException e) {
                    System.out.println("Клиент нормально закрыл соединение: " + clientSocket.getInetAddress());
                    break;
                } catch (SocketException e) {
                    System.out.println("Клиент оборвал соединение: " + clientSocket.getInetAddress());
                    break;
                } catch (ClassNotFoundException e) {
                    System.err.println("Ошибка чтения данных: " + e.getMessage());
                    output.writeObject(new ExecutionResponse(false, "Ошибка чтения данных: " + e.getMessage()));
                } catch (Exception e) {
                    System.err.println("Ошибка обработки команды: " + e.getMessage());
                    e.printStackTrace();
                    output.writeObject(new ExecutionResponse(false, "Внутренняя ошибка сервера: " + e.getMessage()));
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка обработки клиента: " + e.getMessage());
        }
    }
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;

public class ExecutionResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private final boolean success;
    private final String message;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        // Name
        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        // Coordinate X
        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        // Coordinate Y
        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        // Устанавливаем координаты один раз после успешного ввода x и y
        humanBeing.setCoordinates(new Coordinates(x, y));

        // Real Hero
        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        // Has Toothpick
        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        // Impact Speed
        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        // Weapon Type
        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        // Mood
        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood.valueOf(moodInput.toUpperCase()); // Validate input
                humanBeing.setMood(moodInput);
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        // Car
        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        // Creation Date (set automatically)
        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;
import java.io.Serializable;

public class Request implements Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }

    @Override
    public String toString() {
        return "Request{commandName='" + commandName + "', argument=" + argument + ", userId=" + userId + "}";
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package main;

import models.Car;
import models.HumanBeing;
import models.Mood;
import models.WeaponType;
import utility.*;
import utility.Console;

import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

public class ClientMain {
    private static Integer userId = null;
    private static List<String> users = new ArrayList<>();

    public static void main(String[] args) {
        String host = "localhost";
        int port = 5000;
        Console console = new StandardConsole();

        try (Socket socket = new Socket(host, port);
             ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
             ObjectInputStream input = new ObjectInputStream(socket.getInputStream())) {

            console.println("Подключено к серверу: " + host + ":" + port);

            while (true) {
                console.println("Введите команду: ");
                String command = console.read().trim();
                Object argument = null;

                if (command.equals("exit")) {
                    output.writeObject(command);
                    output.writeObject(null);
                    output.writeObject(userId);
                    break;
                }

                String[] parts = command.split("\\s+", 2);
                String commandName = parts[0].toLowerCase();

                if (commandName.equals("delete_user")) {
                    if (userId == null) {
                        console.println("Ошибка: необходимо авторизоваться");
                        continue;
                    }
                    output.writeObject("get_users");
                    output.writeObject(null);
                    output.writeObject(userId);
                    output.flush();

                    ExecutionResponse response = (ExecutionResponse) input.readObject();
                    if (!response.isSuccess()) {
                        console.println("Ошибка при получении списка пользователей: " + response.getMessage());
                        continue;
                    }

                    String[] usersList = response.getMessage().split("\n");
                    users.clear();
                    for (String user : usersList) {
                        if (!user.trim().isEmpty()) {
                            users.add(user.trim());
                        }
                    }

                    if (users.isEmpty()) {
                        console.println("Список пользователей пуст");
                        continue;
                    }

                    console.println("Список пользователей:");
                    for (int i = 0; i < users.size(); i++) {
                        console.println((i + 1) + ". " + users.get(i));
                    }

                    console.println("Введите номер пользователя для удаления:");
                    String inputStr = console.read().trim();
                    int userNumber;
                    try {
                        userNumber = Integer.parseInt(inputStr);
                        if (userNumber < 1 || userNumber > users.size()) {
                            console.println("Ошибка: неверный номер пользователя");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректный номер");
                        continue;
                    }

                    String usernameToDelete = users.get(userNumber - 1);
                    console.println("Вы уверены, что хотите удалить пользователя " + usernameToDelete + "? (да/нет)");
                    String confirmation = console.read().trim().toLowerCase();
                    if (!confirmation.equals("да")) {
                        console.println("Удаление отменено");
                        continue;
                    }

                    users.remove(userNumber - 1);
                    console.println("Пользователь " + usernameToDelete + " успешно удален");
                    continue;
                }

                if (commandName.equals("register") || commandName.equals("login")) {
                    console.println("Введите имя пользователя (не пустое):");
                    String username = console.read().trim();
                    if (username.isEmpty()) {
                        console.println("Ошибка: имя пользователя не может быть пустым");
                        continue;
                    }

                    console.println("Введите пароль (не пустой):");
                    String password = console.read().trim();
                    if (password.isEmpty()) {
                        console.println("Ошибка: пароль не может быть пустым");
                        continue;
                    }

                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(username);
                    humanBeing.setCar(new Car(password));
                    argument = humanBeing;
                } else if (commandName.equals("execute_script")) {
                    console.println("Введите путь к файлу скрипта:");
                    String scriptPath = console.read().trim();
                    if (scriptPath.isEmpty()) {
                        console.println("Ошибка: путь к файлу не может быть пустым");
                        continue;
                    }
                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(scriptPath);
                    argument = humanBeing;
                } else if (commandName.equals("removebyid")) {
                    console.println("Введите id элемента для удаления (целое положительное число):");
                    String idInput = console.read().trim();
                    Long id;
                    try {
                        id = Long.parseLong(idInput);
                        if (id <= 0) {
                            console.println("Ошибка: id должен быть положительным числом");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректное целое число для id");
                        continue;
                    }
                    argument = id;
                } else {
                    if (userId == null) {
                        console.println("Ошибка: необходимо войти в систему (login) или зарегистрироваться (register)");
                        continue;
                    }

                    if (commandName.equals("add")) {
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("update")) {
                        console.println("Введите id элемента для обновления (целое положительное число):");
                        String idInput = console.read().trim();
                        Long id;
                        try {
                            id = Long.parseLong(idInput);
                            if (id <= 0) {
                                console.println("Ошибка: id должен быть положительным числом");
                                continue;
                            }
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число для id");
                            continue;
                        }
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            humanBeing.setId(id);
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("filter_starts_with_name")) {
                        console.println("Введите имя (не пустое):");
                        String name = console.read().trim();
                        if (name.isEmpty()) {
                            console.println("Ошибка: имя не может быть пустым");
                            continue;
                        }
                        HumanBeing humanBeing = new HumanBeing();
                        humanBeing.setName(name);
                        argument = humanBeing;
                    } else if (commandName.equals("count_less_than_impact_speed")) {
                        console.println("Введите impactSpeed (целое число):");
                        String impactSpeedInput = console.read().trim();
                        try {
                            long impactSpeed = Long.parseLong(impactSpeedInput);
                            HumanBeing humanBeing = new HumanBeing();
                            humanBeing.setImpactSpeed(impactSpeed);
                            argument = humanBeing;
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число");
                            continue;
                        }
                    }
                }

                output.writeObject(commandName);
                output.writeObject(argument);
                output.writeObject(userId);
                output.flush();

                ExecutionResponse response = (ExecutionResponse) input.readObject();
                console.println("Ответ сервера: " + response.getMessage());

                if (commandName.equals("execute_script")) {
                    if (response.isSuccess()) {
                        console.println("Результат выполнения скрипта:");
                        String message = response.getMessage();
                        if (message != null && !message.isEmpty()) {
                            String[] lines = message.split("\\r?\\n");
                            for (String line : lines) {
                                console.println(line);
                            }
                        } else {
                            console.println("Пустой результат от сервера");
                        }
                    } else {
                        console.println("Ошибка выполнения скрипта: " + response.getMessage());
                    }
                }

                if ((commandName.equals("login") || commandName.equals("register")) && response.isSuccess()) {
                    try {
                        userId = Integer.parseInt(response.getMessage());
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: некорректный userId от сервера");
                    }
                }
            }
        } catch (IOException | ClassNotFoundException e) {
            console.println("Ошибка клиента: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
package main.gui;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.stage.Stage;
import main.gui.controllers.MainWindowController;

import java.util.Locale;
import java.util.ResourceBundle;

public class MainApp extends Application {
    private static Locale locale = new Locale("ru", "RU");
    private static ResourceBundle bundle = ResourceBundle.getBundle("main.gui.locale.messages", locale);

    public static Locale getLocale() { return locale; }
    public static void setLocale(Locale l) {
        locale = l;
        bundle = ResourceBundle.getBundle("main.gui.locale.messages", locale);
    }
    public static ResourceBundle getBundle() { return bundle; }

    @Override
    public void start(Stage primaryStage) throws Exception {
        showAuthWindow();
    }

    public static void showAuthWindow() throws Exception {
        FXMLLoader loader = new FXMLLoader(MainApp.class.getResource("/main/gui/views/auth.fxml"), getBundle());
        Stage stage = new Stage();
        stage.setTitle(bundle.getString("auth.title"));
        stage.setScene(new Scene(loader.load()));
        stage.show();
    }

    public static void showMainWindow(NetworkClient client, Integer userId) throws Exception {
        FXMLLoader loader = new FXMLLoader(MainApp.class.getResource("/main/gui/views/main.fxml"), getBundle());
        Stage stage = new Stage();
        stage.setTitle(bundle.getString("main.title"));
        stage.setScene(new Scene(loader.load()));
        MainWindowController controller = loader.getController();
        controller.initSession(client, userId);
        stage.show();
    }
}
package main.gui;

import utility.ExecutionResponse;

import java.io.*;
import java.net.Socket;

public class NetworkClient implements Closeable {
    private Socket socket;
    private ObjectOutputStream output;
    private ObjectInputStream input;

    public boolean connect(String host, int port) {
        try {
            socket = new Socket(host, port);
            output = new ObjectOutputStream(socket.getOutputStream());
            input = new ObjectInputStream(socket.getInputStream());
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    public ExecutionResponse sendCommand(String command, Object argument, Integer userId) {
        try {
            output.writeObject(command);
            output.writeObject(argument);
            output.writeObject(userId);
            output.flush();
            return (ExecutionResponse) input.readObject();
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка клиента: " + e.getMessage());
        }
    }

    @Override
    public void close() throws IOException {
        if (output != null) output.close();
        if (input != null) input.close();
        if (socket != null) socket.close();
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.MainApp;
import main.gui.NetworkClient;
import models.Car;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.IOException;
import java.util.Locale;

public class AuthController {
    @FXML private TextField usernameField;
    @FXML private PasswordField passwordField;
    @FXML private Button loginButton;
    @FXML private Button registerButton;
    @FXML private ComboBox<String> languageBox;
    @FXML private Label messageLabel;

    private NetworkClient networkClient;
    private Integer userId;

    private int lastLanguageIndex = -1;

    @FXML
    private void initialize() {
        languageBox.getItems().setAll("Русский", "Македонский", "Latviešu", "Español (Colombia)");
        Locale current = MainApp.getLocale();
        int idx = 0;
        if (current.getLanguage().equals("ru")) idx = 0;
        else if (current.getLanguage().equals("mk")) idx = 1;
        else if (current.getLanguage().equals("lv")) idx = 2;
        else if (current.getLanguage().equals("es")) idx = 3;
        languageBox.getSelectionModel().select(idx);
        lastLanguageIndex = idx;

        languageBox.getSelectionModel().selectedIndexProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            if (newVal.intValue() == lastLanguageIndex) return; // если язык не менялся — не перезагружаем
            lastLanguageIndex = newVal.intValue();
            switch (newVal.intValue()) {
                case 0:
                    MainApp.setLocale(new Locale("ru", "RU")); break;
                case 1:
                    MainApp.setLocale(new Locale("mk", "MK")); break;
                case 2:
                    MainApp.setLocale(new Locale("lv", "LV")); break;
                case 3:
                    MainApp.setLocale(new Locale("es", "CO")); break;
            }
            java.util.ResourceBundle.clearCache();
            reload();
        });
    }

    private void reload() {
        try {
            Stage stage = (Stage) usernameField.getScene().getWindow();
            stage.close();
            MainApp.showAuthWindow();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @FXML
    private void handleLogin(javafx.event.ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.empty"));
            return;
        }

        if (networkClient != null) {
            try { networkClient.close(); } catch (IOException ignored) {}
        }
        networkClient = new NetworkClient();
        if (!networkClient.connect("localhost", 5000)) {
            messageLabel.setText("Ошибка соединения с сервером");
            return;
        }
        HumanBeing user = new HumanBeing();
        user.setName(username);
        user.setCar(new Car(password));
        ExecutionResponse response = networkClient.sendCommand("login", user, null);
        if (response.isSuccess()) {
            try {
                userId = Integer.parseInt(response.getMessage());
                messageLabel.setText(MainApp.getBundle().getString("auth.login.success"));
                try {
                    MainApp.showMainWindow(networkClient, userId);
                    Stage stage = (Stage) loginButton.getScene().getWindow();
                    stage.close();
                } catch (Exception e) {
                    e.printStackTrace();
                    messageLabel.setText("Ошибка открытия главного окна: " + e.getMessage());
                }
            } catch (NumberFormatException e) {
                messageLabel.setText("Некорректный userId от сервера");
                try { networkClient.close(); } catch (IOException ignored) {}
            }
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.fail") + " " + response.getMessage());
            try { networkClient.close(); } catch (IOException ignored) {}
        }
    }

    @FXML
    private void handleRegister(javafx.event.ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.empty"));
            return;
        }

        if (networkClient != null) {
            try { networkClient.close(); } catch (IOException ignored) {}
        }
        networkClient = new NetworkClient();
        if (!networkClient.connect("localhost", 5000)) {
            messageLabel.setText("Ошибка соединения с сервером");
            return;
        }
        HumanBeing user = new HumanBeing();
        user.setName(username);
        user.setCar(new Car(password));
        ExecutionResponse response = networkClient.sendCommand("register", user, null);
        if (response.isSuccess()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.success"));
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.fail") + " " + response.getMessage());
            try { networkClient.close(); } catch (IOException ignored) {}
        }
    }

    public NetworkClient getNetworkClient() {
        return networkClient;
    }
    public Integer getUserId() {
        return userId;
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;

public class MainController {
    @FXML private Label userLabel;
    @FXML private TableView<?> tableView; // замените ? на вашу модель
    @FXML private Canvas canvas;

    @FXML
    private void initialize() {
        userLabel.setText("User: ...");
        // Настройка TableView, загрузка данных с сервера
    }

    @FXML
    private void handleCanvasClick(MouseEvent event) {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        // TODO: обработка клика, выделение объекта, вывод информации
    }

    // Добавьте методы для фильтрации, сортировки, обновления таблицы, работы с графикой и т.д.
}
package main.gui.controllers;

import javafx.collections.FXCollections;
import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.MainApp;
import main.gui.NetworkClient;
import utility.ExecutionResponse;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

public class MainWindowController {
    @FXML private ComboBox<String> languageBox;
    @FXML private ListView<String> commandListView;
    @FXML private Label commandTitle;
    @FXML private TextArea commandOutput;
    @FXML private Button executeButton;
    @FXML private TextField argumentField;
    @FXML private Button registerButton;
    @FXML private Button exitButton;

    private NetworkClient networkClient;
    private Integer userId;

    private final List<String> commands = Arrays.asList(
            "add", "update", "remove_head", "clear", "info", "show",
            "help", "filter_starts_with_name", "print_unique_impact_speed",
            "count_less_than_impact_speed", "execute_script", "removebyid"
    );

    private int lastLanguageIndex = -1;

    public void initSession(NetworkClient networkClient, Integer userId) {
        this.networkClient = networkClient;
        this.userId = userId;
        List<String> visibleCommands = commands.stream()
                .filter(cmd -> !cmd.equals("login") && !cmd.equals("register"))
                .collect(Collectors.toList());
        commandListView.setItems(FXCollections.observableArrayList(visibleCommands));
    }

    @FXML
    private void initialize() {
        languageBox.getItems().setAll("Русский", "Македонский", "Latviešu", "Español (Colombia)");
        Locale current = MainApp.getLocale();
        int idx = 0;
        if (current.getLanguage().equals("ru")) idx = 0;
        else if (current.getLanguage().equals("mk")) idx = 1;
        else if (current.getLanguage().equals("lv")) idx = 2;
        else if (current.getLanguage().equals("es")) idx = 3;
        languageBox.getSelectionModel().select(idx);
        lastLanguageIndex = idx;

        languageBox.getSelectionModel().selectedIndexProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            if (newVal.intValue() == lastLanguageIndex) return;
            lastLanguageIndex = newVal.intValue();
            switch (newVal.intValue()) {
                case 0:
                    MainApp.setLocale(new Locale("ru", "RU")); break;
                case 1:
                    MainApp.setLocale(new Locale("mk", "MK")); break;
                case 2:
                    MainApp.setLocale(new Locale("lv", "LV")); break;
                case 3:
                    MainApp.setLocale(new Locale("es", "CO")); break;
            }
            java.util.ResourceBundle.clearCache();
            reload();
        });

        commandListView.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            commandTitle.setText(newVal == null ? "" : newVal);
            commandOutput.clear();
            argumentField.clear();
        });
        commandListView.getSelectionModel().selectFirst();

        executeButton.setOnAction(event -> executeSelectedCommand());
        argumentField.setOnAction(event -> executeSelectedCommand());
        registerButton.setOnAction(event -> goToRegister());
        exitButton.setOnAction(event -> exitApp());
    }

    private void executeSelectedCommand() {
        String command = commandListView.getSelectionModel().getSelectedItem();
        if (command == null) return;
        String arg = argumentField.getText();

        Object argument = null;
        try {
            if (!arg.isEmpty()) {
                if (command.equals("removebyid") || command.equals("update") || command.equals("count_less_than_impact_speed")) {
                    argument = Long.parseLong(arg);
                } else {
                    argument = arg;
                }
            }
        } catch (Exception e) {
            commandOutput.setText("Ошибка ввода аргумента: " + e.getMessage());
            return;
        }

        if ("help".equals(command)) {
            // --- Локализация: передаем язык в поле name HumanBeing ---
            String currentLang = MainApp.getLocale().getLanguage();
            models.HumanBeing langArg = new models.HumanBeing();
            langArg.setName(currentLang);
            ExecutionResponse response = networkClient.sendCommand(command, langArg, userId);
            String filtered = Arrays.stream(response.getMessage().split("\\r?\\n"))
                    .filter(line -> !line.trim().startsWith("login") && !line.trim().startsWith("register"))
                    .collect(Collectors.joining("\n"));
            commandOutput.setText(filtered);
        } else {
            ExecutionResponse response = networkClient.sendCommand(command, argument, userId);
            commandOutput.setText(response.getMessage());
        }
    }

    private void goToRegister() {
        try {
            if (networkClient != null) {
                networkClient.close();
            }
        } catch (IOException ignored) {}
        try {
            Stage stage = (Stage) registerButton.getScene().getWindow();
            stage.close();
            MainApp.showAuthWindow();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void exitApp() {
        try {
            networkClient.sendCommand("exit", null, userId);
            networkClient.close();
        } catch (IOException ignored) {}
        Stage stage = (Stage) exitButton.getScene().getWindow();
        stage.close();
    }

    private void reload() {
        try {
            Stage stage = (Stage) languageBox.getScene().getWindow();
            NetworkClient oldClient = this.networkClient;
            Integer oldUserId = this.userId;
            stage.close();
            MainApp.showMainWindow(oldClient, oldUserId);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return "HumanBeing{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", coordinates=" + coordinates +
                ", creationDate=" + creationDate +
                ", realHero=" + realHero +
                ", hasToothpick=" + hasToothpick +
                ", impactSpeed=" + impactSpeed +
                ", weaponType=" + weaponType +
                ", mood=" + mood +
                ", car=" + car +
                ", userId=" + userId +
                '}';
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;

public class ExecutionResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private final boolean success;
    private final String message;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        humanBeing.setCoordinates(new Coordinates(x, y));

        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood mood = Mood.valueOf(moodInput.toUpperCase());
                humanBeing.setMood(mood.toString());
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;

public class Request implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package commands;

import models.HumanBeing;
import utility.ExecutionResponse;
import managers.CollectionManager;

public class Add extends Command {
    private final CollectionManager collectionManager;

    public Add(CollectionManager collectionManager) {
        super("add", "добавить новый элемент в коллекцию");
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null) {
            return new ExecutionResponse(false, "Ошибка: объект не может быть null");
        }
        humanBeing.setUserId(userId);
        boolean success = collectionManager.add(humanBeing, userId);
        if (success) {
            return new ExecutionResponse(true, "Элемент успешно добавлен с id: " + humanBeing.getId());
        } else {
            return new ExecutionResponse(false, "Не удалось добавить элемент");
        }
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.Locale;
import java.util.ResourceBundle;

public class Clear extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Clear(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("clear", "очистить коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: clear, userId: " + userId);

        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("clear.error.not_authorized"));
        }

        boolean success = collectionManager.clear(userId);
        if (success) {
            return new ExecutionResponse(true, bundle.getString("clear.success") + " " + userId);
        } else {
            return new ExecutionResponse(false, bundle.getString("clear.error.failed"));
        }
    }
}
package commands;

import models.HumanBeing;
import utility.ExecutionResponse;

public abstract class Command {
    protected String name;
    protected String description;

    public Command(String name, String description) {
        this.name = name;
        this.description = description;
    }

    public abstract ExecutionResponse execute(HumanBeing argument, Integer userId);

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class CountLessThanImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public CountLessThanImpactSpeed(Console console, CollectionManager collectionManager) {
        super("count_less_than_impact_speed", "вывести количество элементов, значение поля impactSpeed которых меньше заданного");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: count_less_than_impact_speed, userId: " + userId);
        if (argument == null || argument.getImpactSpeed() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать значение impactSpeed");
        }

        long threshold = argument.getImpactSpeed();
        long count = collectionManager.getCollection().stream()
                .filter(h -> h.getUserId().equals(userId))
                .filter(h -> h.getImpactSpeed() < threshold)
                .count();

        return new ExecutionResponse(true, "Количество элементов с impactSpeed меньше " + threshold + ": " + count);
    }
}
package commands;

import models.HumanBeing;
import models.Coordinates;
import models.Car;
import models.WeaponType;
import models.Mood;
import utility.Console;
import utility.ExecutionResponse;
import managers.CommandManager;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;

public class ExecuteScript extends Command {
    private final Console console;
    private final CommandManager commandManager;
    private final Set<String> executedFiles = new HashSet<>();
    private final List<String> inputLines = new ArrayList<>();

    public ExecuteScript(Console console, CommandManager commandManager) {
        super("execute_script", "исполнить скрипт из файла");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || humanBeing.getName() == null || humanBeing.getName().trim().isEmpty()) {
            return new ExecutionResponse(false, "Требуется путь к файлу скрипта");
        }

        String scriptPath = humanBeing.getName().trim();

        try {
            String absolutePath = Paths.get(scriptPath).toAbsolutePath().toString();

            if (executedFiles.contains(absolutePath)) {
                return new ExecutionResponse(false, "Обнаружена рекурсия: файл " + scriptPath + " уже выполняется");
            }

            executedFiles.add(absolutePath);
            StringBuilder scriptOutput = new StringBuilder();

            try (BufferedReader reader = new BufferedReader(new FileReader(absolutePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith("#")) continue;

                    String[] parts = line.split("\\s+", 2);
                    String commandName = parts[0].toLowerCase();
                    HumanBeing commandHumanBeing = new HumanBeing();

                    if (commandName.equals("execute_script")) {
                        commandHumanBeing.setName(parts.length > 1 ? parts[1] : "");
                    } else if (commandName.equals("add") || commandName.equals("update")) {
                        // Читаем следующие 9 строк для команды add/update
                        inputLines.clear();
                        for (int i = 0; i < 9; i++) {
                            String nextLine = reader.readLine();
                            if (nextLine == null) {
                                return new ExecutionResponse(false, "Неожиданный конец файла при чтении параметров команды " + commandName);
                            }
                            nextLine = nextLine.trim();
                            if (nextLine.isEmpty()) {
                                i--; // Пропускаем пустые строки
                                continue;
                            }
                            inputLines.add(nextLine);
                        }
                        // Устанавливаем параметры в объект HumanBeing в правильном порядке
                        if (inputLines.size() >= 1) commandHumanBeing.setName(inputLines.get(0));
                        if (inputLines.size() >= 3) {
                            try {
                                double x = Double.parseDouble(inputLines.get(1));
                                float y = Float.parseFloat(inputLines.get(2));
                                commandHumanBeing.setCoordinates(new Coordinates(x, y));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении координат: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 4) commandHumanBeing.setRealHero(Boolean.parseBoolean(inputLines.get(3)));
                        if (inputLines.size() >= 5) commandHumanBeing.setHasToothpick(Boolean.parseBoolean(inputLines.get(4)));
                        if (inputLines.size() >= 6) {
                            try {
                                commandHumanBeing.setImpactSpeed(Long.parseLong(inputLines.get(5)));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении impactSpeed: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 7) {
                            try {
                                commandHumanBeing.setWeaponType(WeaponType.valueOf(inputLines.get(6)));
                            } catch (IllegalArgumentException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении weaponType: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 8) commandHumanBeing.setMood(inputLines.get(7));
                        if (inputLines.size() >= 9) {
                            String carName = inputLines.get(8);
                            commandHumanBeing.setCar(new Car(carName));
                        }
                        // Устанавливаем дату создания для команды add
                        if (commandName.equals("add")) {
                            commandHumanBeing.setCreationDate(LocalDateTime.now());
                        }
                    } else if (commandName.equals("removebyid")) {
                        if (parts.length > 1) {
                            try {
                                commandHumanBeing.setId(Long.parseLong(parts[1]));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка: ID должен быть числом");
                            }
                        }
                    } else if (parts.length > 1) {
                        commandHumanBeing.setName(parts[1]);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, commandHumanBeing, userId);
                    scriptOutput.append(response.getMessage()).append("\n");
                }
            } finally {
                executedFiles.remove(absolutePath);
            }

            return new ExecutionResponse(true, scriptOutput.toString().trim());
        } catch (IOException e) {
            return new ExecutionResponse(false, "Ошибка при чтении файла: " + e.getMessage());
        }
    }
}
package commands;

import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Exit extends Command {
    private final Console console;

    public Exit(Console console) {
        super("exit", "завершить работу клиента");
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Завершение работы клиента");
        return new ExecutionResponse(true, "Клиент отключен");
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class FilterStartsWithName extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public FilterStartsWithName(Console console, CollectionManager collectionManager) {
        super("filter_starts_with_name", "вывести элементы, значение поля name которых начинается с заданной подстроки");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: filter_starts_with_name, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }
        if (argument == null || argument.getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать подстроку для поля name");
        }

        String prefix = argument.getName();
        console.println("Ищем элементы с именем, начинающимся с: " + prefix);
        
        StringBuilder response = new StringBuilder("Элементы с именем, начинающимся с \"" + prefix + "\":\n");
        boolean found = false;
        int totalElements = 0;
        int matchingElements = 0;

        for (HumanBeing human : collectionManager.getCollection()) {
            totalElements++;
            console.println("Проверяем элемент: " + human.getName() + " (userId: " + human.getUserId() + ")");
            if (human.getName().startsWith(prefix) && human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                matchingElements++;
            }
        }

        console.println("Всего элементов в коллекции: " + totalElements);
        console.println("Найдено совпадающих элементов: " + matchingElements);

        if (!found) {
            response.append("Элементы не найдены.");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CommandManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.Locale;
import java.util.ResourceBundle;

public class Help extends Command {
    private final Console console;
    private final CommandManager commandManager;

    public Help(Console console, CommandManager commandManager) {
        super("help", "вывести справку по доступным командам");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        Locale locale = new Locale(lang);

        ResourceBundle bundle; // <-- объявляем тут!ф
        try {
            bundle = ResourceBundle.getBundle("messages", locale);
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        StringBuilder response = new StringBuilder(
                bundle.containsKey("help.title")
                        ? bundle.getString("help.title") + "\n"
                        : "Доступные команды:\n"
        );

        for (var entry : commandManager.getCommands().entrySet()) {
            String name = entry.getKey();
            Command command = entry.getValue();
            String key = "help." + name;
            String description = bundle.containsKey(key)
                    ? bundle.getString(key)
                    : command.getDescription();
            response.append(name).append(": ").append(description).append("\n");
        }
        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;

public class Info extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Info(Console console, CollectionManager collectionManager) {
        super("info", "вывести информацию о коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: info, userId: " + userId);

        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("info.error.not_authorized"));
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        int totalElements = collection.size();
        int userElements = 0;
        for (HumanBeing human : collection) {
            if (human.getUserId().equals(userId)) userElements++;
        }

        StringBuilder response = new StringBuilder();
        response.append(bundle.getString("info.type")).append(" ").append(collection.getClass().getSimpleName()).append("\n");
        response.append(bundle.getString("info.init_date")).append(" ").append(collectionManager.getInitializationDate()).append("\n");
        response.append(bundle.getString("info.total_elements")).append(" ").append(totalElements).append("\n");
        response.append(bundle.getString("info.user_elements")).append(" ").append(userElements);

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Login extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Login(DatabaseManager dbManager, Console console) {
        super("login", "авторизоваться с существующим пользователем");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: login, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: " + "необходимо указать имя пользователя и пароль");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка авторизации: username=" + username);
        Integer resultId = dbManager.loginUser(username, password);
        if (resultId != null) {
            return new ExecutionResponse(true, String.valueOf(resultId));
        } else {
            return new ExecutionResponse(false, "Ошибка авторизации: неверный username или password");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashSet;
import java.util.Set;

public class PrintUniqueImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public PrintUniqueImpactSpeed(Console console, CollectionManager collectionManager) {
        super("print_unique_impact_speed", "вывести уникальные значения поля impactSpeed");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: print_unique_impact_speed, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        Set<Long> uniqueSpeeds = new HashSet<>();
        for (HumanBeing human : collectionManager.getCollection()) {
            if (human.getUserId().equals(userId)) {
                uniqueSpeeds.add(human.getImpactSpeed());
            }
        }

        if (uniqueSpeeds.isEmpty()) {
            return new ExecutionResponse(true, "У вас нет элементов в коллекции.");
        }

        StringBuilder response = new StringBuilder("Уникальные значения impactSpeed:\n");
        for (Long speed : uniqueSpeeds) {
            response.append(speed).append("\n");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Register extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Register(DatabaseManager dbManager, Console console) {
        super("register", "зарегистрировать нового пользователя");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: register, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать username и password");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка регистрации: username=" + username);

        Integer newUserId = dbManager.registerUser(username, password);
        if (newUserId != null) {
            return new ExecutionResponse(true, String.valueOf(newUserId));
        } else {
            return new ExecutionResponse(false, "Ошибка регистрации: пользователь уже существует или неверные данные");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class RemoveById extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveById(Console console, CollectionManager collectionManager) {
        super("removebyid", "удалить элемент из коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: removebyid, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }
        if (argument == null || argument.getId() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать id для удаления");
        }

        Long id = argument.getId();
        // Debug: Print collection contents
        console.println("Содержимое коллекции перед удалением id=" + id + ":");
        for (Long key : collectionManager.getCollectionMap().keySet()) {
            HumanBeing hb = collectionManager.getCollectionMap().get(key);
            console.println("id=" + hb.getId() + ", userId=" + hb.getUserId());
        }

        HumanBeing humanBeing = collectionManager.getCollectionMap().get(id);
        if (humanBeing == null) {
            console.println("Элемент с id " + id + " не найден в коллекции");
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " не существует в коллекции");
        }
        if (!humanBeing.getUserId().equals(userId)) {
            console.println("Элемент с id " + id + " принадлежит userId=" + humanBeing.getUserId());
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " принадлежит другому пользователю");
        }

        boolean success = collectionManager.remove(id, userId);
        if (success) {
            console.println("Элемент с id " + id + " успешно удален");
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно удален");
        } else {
            console.println("Ошибка удаления id=" + id + " из базы данных");
            return new ExecutionResponse(false, "Ошибка при удалении элемента с id " + id + ": не удалось удалить из базы данных");
        }
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;

public class RemoveHead extends Command {
    private final CollectionManager collectionManager;
    private final DatabaseManager databaseManager;
    private final Console console;

    public RemoveHead(CollectionManager collection, Console console, DatabaseManager databaseManager) {
        super("remove_head", "вывести и удалить первый элемент коллекции");
        this.collectionManager = collection;
        this.databaseManager = databaseManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: remove_head, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        if (collection.isEmpty()) {
            return new ExecutionResponse(false, "Коллекция пуста");
        }

        HumanBeing head = collection.stream()
                .filter(h -> h.getUserId().equals(userId))
                .findFirst()
                .orElse(null);

        if (head == null) {
            return new ExecutionResponse(false, "Нет элементов, принадлежащих пользователю с ID " + userId);
        }

        boolean success = collectionManager.remove(head.getId(), userId);
        if (success) {
            return new ExecutionResponse(true, "Первый элемент: " + head.toString() + "\nЭлемент успешно удален");
        } else {
            return new ExecutionResponse(false, "Ошибка при удалении первого элемента");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;

public class Show extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Show(Console console, CollectionManager collectionManager) {
        super("show", "вывести все элементы коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: show, userId: " + userId);

        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("show.error.not_authorized"));
        }

        StringBuilder response = new StringBuilder(bundle.getString("show.header") + "\n");
        List<HumanBeing> collection = collectionManager.getCollection();
        boolean found = false;
        int totalElements = 0;
        int userElements = 0;

        for (HumanBeing human : collection) {
            totalElements++;
            if (human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                userElements++;
            }
        }

        console.println(bundle.getString("show.console.total") + totalElements);
        console.println(bundle.getString("show.console.user") + userElements);

        if (!found) {
            response.append(bundle.getString("show.no_elements"));
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Update extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Update(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("update", "обновить элемент коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        console.println("Выполняется команда: update, userId: " + userId);
        
        if (humanBeing == null) {
            return new ExecutionResponse(false, "Ошибка: объект HumanBeing не предоставлен");
        }
        
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        Long id = humanBeing.getId();
        if (id == null) {
            return new ExecutionResponse(false, "Ошибка: id не указан");
        }
        
        if (id <= 0) {
            return new ExecutionResponse(false, "Ошибка: id должен быть положительным числом");
        }

        // Check if the element exists and belongs to the user
        HumanBeing existingHuman = collectionManager.getCollectionMap().get(id);
        if (existingHuman == null) {
            return new ExecutionResponse(false, "Ошибка: элемент с указанным id не найден");
        }

        if (!existingHuman.getUserId().equals(userId)) {
            return new ExecutionResponse(false, "Ошибка: вы не можете изменить элемент, созданный другим пользователем");
        }

        // Update the element
        boolean success = collectionManager.update(id, humanBeing, userId);
        if (success) {
            return new ExecutionResponse(true, "Элемент успешно обновлен");
        } else {
            return new ExecutionResponse(false, "Ошибка при обновлении элемента");
        }
    }
}
package main;

import managers.CollectionManager;
import managers.CommandManager;
import managers.DatabaseManager;
import server.Server;
import utility.Console;
import utility.StandardConsole;

public class ServerMain {
    public static void main(String[] args) {
        Console console = new StandardConsole();
        DatabaseManager databaseManager = new DatabaseManager();
        CollectionManager collectionManager = new CollectionManager(databaseManager);
        CommandManager commandManager = new CommandManager(console, collectionManager, databaseManager);
        Server server = new Server(5000, commandManager);
        server.run();
    }
}
package managers;

import models.HumanBeing;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CollectionManager {
    private final Map<Long, HumanBeing> collection;
    private final DatabaseManager dbManager;
    private final LocalDateTime initializationDate;

    public CollectionManager(DatabaseManager dbManager) {
        this.collection = new ConcurrentHashMap<>();
        this.dbManager = dbManager;
        this.initializationDate = LocalDateTime.now();
    }

    public List<HumanBeing> getCollection() {
        return dbManager.loadHumanBeings();
    }

    public LocalDateTime getInitializationDate() {
        return initializationDate;
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || userId == null) {
            return false;
        }
        if (dbManager.add(humanBeing, userId)) {
            collection.put(humanBeing.getId(), humanBeing);
            return true;
        }
        return false;
    }

    public boolean update(Long id, HumanBeing humanBeing, Integer userId) {
        return dbManager.updateHumanBeing(id, humanBeing, userId);
    }

    public boolean remove(Long id, Integer userId) {
        return dbManager.removeHumanBeing(id, userId);
    }

    public boolean clear(Integer userId) {
        return dbManager.clearHumanBeings(userId);
    }

    public Map<Long, HumanBeing> getCollectionMap() {
        return collection;
    }
}
package managers;

import commands.*;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashMap;
import java.util.Map;

public class CommandManager {
    private final Map<String, Command> commands = new HashMap<>();
    private final Console console;

    public CommandManager(Console console, CollectionManager collectionManager, DatabaseManager databaseManager) {
        this.console = console;
        commands.put("add", new Add(collectionManager));
        commands.put("update", new Update(console, collectionManager, databaseManager));
        commands.put("remove_head", new RemoveHead(collectionManager, console, databaseManager));
        commands.put("clear", new Clear(console, collectionManager, databaseManager));
        commands.put("info", new Info(console, collectionManager));
        commands.put("show", new Show(console, collectionManager));
        commands.put("login", new Login(databaseManager, console));
        commands.put("register", new Register(databaseManager, console));
        commands.put("exit", new Exit(console));
        commands.put("help", new Help(console, this));
        commands.put("filter_starts_with_name", new FilterStartsWithName(console, collectionManager));
        commands.put("print_unique_impact_speed", new PrintUniqueImpactSpeed(console, collectionManager));
        commands.put("count_less_than_impact_speed", new CountLessThanImpactSpeed(console, collectionManager));
        commands.put("execute_script", new ExecuteScript(console, this));
        commands.put("removebyid", new RemoveById(console, collectionManager));
    }

    public ExecutionResponse executeCommand(String commandName, HumanBeing humanBeing, Integer userId) {
        Command command = commands.get(commandName);
        if (command == null) {
            return new ExecutionResponse(false, "Команда '" + commandName + "' не найдена. Введите 'help' для списка команд.");
        }
        return command.execute(humanBeing, userId);
    }

    public Map<String, Command> getCommands() {
        return commands;
    }
}
package managers;

import models.*;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class DatabaseManager {
    private final String url = "jdbc:postgresql://localhost:5432/studs";
    private final String user = "s434931";
    private final String password = "250806";
    private Connection connection;
    private final Map<Long, HumanBeing> collection;

    public DatabaseManager() {
        this.collection = new ConcurrentHashMap<>();
        connect();
        loadHumanBeings();
    }

    private void connect() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
            }
            connection = DriverManager.getConnection(url, user, password);
            System.out.println("Подключение к базе данных установлено: " + url);
        } catch (SQLException e) {
            System.err.println("Ошибка подключения к базе данных: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void close() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                System.out.println("Соединение с базой данных закрыто");
            }
        } catch (SQLException e) {
            System.err.println("Ошибка при закрытии соединения с базой данных: " + e.getMessage());
        }
    }

    public Map<Long, HumanBeing> getCollection() {
        return collection;
    }

    public List<HumanBeing> loadHumanBeings() {
        collection.clear();
        List<HumanBeing> humans = new ArrayList<>();
        String query = "SELECT * FROM human_beings";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            while (rs.next()) {
                HumanBeing human = new HumanBeing();
                human.setId(rs.getLong("id"));
                human.setName(rs.getString("name"));
                human.setCoordinates(new Coordinates(
                        rs.getDouble("coordinate_x"),
                        rs.getFloat("coordinate_y")
                ));
                human.setCreationDate(rs.getTimestamp("creation_date").toLocalDateTime());
                human.setRealHero(rs.getBoolean("real_hero"));
                human.setHasToothpick(rs.getObject("has_toothpick") != null ? rs.getBoolean("has_toothpick") : null);
                human.setImpactSpeed(rs.getLong("impact_speed"));
                human.setWeaponType(WeaponType.valueOf(rs.getString("weapon_type")));
                human.setMood(rs.getString("mood"));
                human.setCar(new Car(rs.getString("car_name")));
                human.setUserId(rs.getInt("user_id"));
                collection.put(human.getId(), human);
                humans.add(human);
            }
            System.out.println("Коллекция загружена из базы данных: " + collection.size() + " элементов");
            return humans;
        } catch (SQLException e) {
            System.err.println("Ошибка загрузки коллекции: " + e.getMessage());
            return humans;
        }
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        String sql = "INSERT INTO human_beings (name, coordinate_x, coordinate_y, creation_date, impact_speed, real_hero, has_toothpick, weapon_type, mood, car_name, user_id) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setInt(11, userId);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    long id = rs.getLong(1);
                    humanBeing.setId(id);
                    return true;
                }
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка при добавлении элемента: " + e.getMessage());
            return false;
        }
    }

    public boolean removeHumanBeing(Long id, Integer userId) {
        if (id == null || userId == null) return false;
        String query = "DELETE FROM human_beings WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setLong(1, id);
            pstmt.setInt(2, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.remove(id);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка удаления: " + e.getMessage());
            return false;
        }
    }

    public boolean updateHumanBeing(Long id, HumanBeing humanBeing, Integer userId) {
        if (id == null || humanBeing == null || userId == null) return false;
        String query = "UPDATE human_beings SET name = ?, coordinate_x = ?, coordinate_y = ?, creation_date = ?, impact_speed = ?, real_hero = ?, has_toothpick = ?, weapon_type = ?, mood = ?, car_name = ? WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setLong(11, id);
            pstmt.setInt(12, userId);

            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                humanBeing.setId(id);
                humanBeing.setUserId(userId);
                collection.put(id, humanBeing);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка обновления: " + e.getMessage());
            return false;
        }
    }

    public boolean clearHumanBeings(Integer userId) {
        if (userId == null) return false;
        String query = "DELETE FROM human_beings WHERE user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setInt(1, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.entrySet().removeIf(entry -> entry.getValue().getUserId().equals(userId));
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка очистки: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    public Integer loginUser(String username, String password) {
        String query = "SELECT id, password FROM users WHERE username = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, username);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                String storedPassword = rs.getString("password");
                String hashedInputPassword = hashPassword(password);
                if (hashedInputPassword.equals(storedPassword)) {
                    return rs.getInt("id");
                }
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка авторизации: " + e.getMessage());
            return null;
        }
    }

    public Integer registerUser(String username, String password) {
        String query = "INSERT INTO users (username, password) VALUES (?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            String hashedPassword = hashPassword(password);
            System.out.println("Debug - Registration:");
            System.out.println("Username: " + username);
            System.out.println("Password: " + password);
            System.out.println("Hashed password: " + hashedPassword);
            pstmt.setString(1, username);
            pstmt.setString(2, hashedPassword);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt("id");
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка регистрации: " + e.getMessage());
            return null;
        }
    }

    private String hashPassword(String password) {
        int hash = password.hashCode();
        hash = hash * 31 + "SALT".hashCode();
        hash = hash * 31 + password.length();
        return String.format("%d", hash);
    }
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return String.format("(x=%.2f, y=%.2f)", x, y);
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return String.format("HumanBeing{id=%d, name='%s', coordinates=%s, creationDate=%s, realHero=%b, hasToothpick=%s, impactSpeed=%d, weaponType=%s, mood=%s, car=%s, userId=%d}",
                id, name, coordinates, creationDate, realHero, hasToothpick, impactSpeed, weaponType, mood, car, userId);
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package server;

import managers.CommandManager;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    private final int port;
    private final CommandManager commandManager;

    public Server(int port, CommandManager commandManager) {
        this.port = port;
        this.commandManager = commandManager;
    }

    public void run() {
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Сервер запущен на порту " + port);
            while (true) {
                try (Socket clientSocket = serverSocket.accept()) {
                    System.out.println("Клиент подключен: " + clientSocket.getInetAddress());
                    handleClient(clientSocket);
                } catch (Exception e) {
                    System.out.println("Ошибка обработки клиента: " + e.getMessage());
                    e.printStackTrace();
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка сервера: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleClient(Socket clientSocket) throws IOException {
        try (ObjectInputStream input = new ObjectInputStream(clientSocket.getInputStream());
             ObjectOutputStream output = new ObjectOutputStream(clientSocket.getOutputStream())) {

            while (!clientSocket.isClosed()) {
                try {
                    String commandName = (String) input.readObject();
                    Object argument = input.readObject();
                    Integer userId = (Integer) input.readObject();

                    System.out.println("Получен запрос: command=" + commandName + ", userId=" + userId);
                    if (argument != null) {
                        if (argument instanceof HumanBeing) {
                            System.out.println("Аргумент: " + ((HumanBeing) argument).getName());
                        } else if (argument instanceof Long) {
                            System.out.println("Аргумент: id=" + argument);
                        } else {
                            System.out.println("Аргумент: " + argument);
                        }
                    } else {
                        System.out.println("Аргумент: null");
                    }

                    HumanBeing humanBeing = null;
                    if (argument instanceof HumanBeing) {
                        humanBeing = (HumanBeing) argument;
                    } else if (commandName.equals("removebyid") && argument instanceof Long) {
                        humanBeing = new HumanBeing();
                        humanBeing.setId((Long) argument);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, humanBeing, userId);

                    output.writeObject(response);
                    output.flush();

                    if (commandName.equals("exit")) {
                        System.out.println("Клиент отключен: " + clientSocket.getInetAddress());
                        break;
                    }
                } catch (ClassNotFoundException e) {
                    System.err.println("Ошибка чтения данных: " + e.getMessage());
                    output.writeObject(new ExecutionResponse(false, "Ошибка чтения данных: " + e.getMessage()));
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка обработки клиента: " + e.getMessage());
            throw e;
        }
    }
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;

public class ExecutionResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private final boolean success;
    private final String message;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        // Name
        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        // Coordinate X
        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        // Coordinate Y
        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        // Устанавливаем координаты один раз после успешного ввода x и y
        humanBeing.setCoordinates(new Coordinates(x, y));

        // Real Hero
        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        // Has Toothpick
        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        // Impact Speed
        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        // Weapon Type
        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        // Mood
        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood.valueOf(moodInput.toUpperCase()); // Validate input
                humanBeing.setMood(moodInput);
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        // Car
        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        // Creation Date (set automatically)
        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;

import java.util.Locale;
import java.util.ResourceBundle;

public class LocalizationUtil {
    public static ResourceBundle getBundle(HumanBeing argument) {
        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        try {
            return ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            return ResourceBundle.getBundle("messages", new Locale("ru"));
        }
    }
}
package utility;

import models.HumanBeing;
import java.io.Serializable;

public class Request implements Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }

    @Override
    public String toString() {
        return "Request{commandName='" + commandName + "', argument=" + argument + ", userId=" + userId + "}";
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package main;

import models.Car;
import models.HumanBeing;
import models.Mood;
import models.WeaponType;
import utility.*;
import utility.Console;

import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

public class ClientMain {
    private static Integer userId = null;
    private static List<String> users = new ArrayList<>();

    public static void main(String[] args) {
        String host = "localhost";
        int port = 5000;
        Console console = new StandardConsole();

        try (Socket socket = new Socket(host, port);
             ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
             ObjectInputStream input = new ObjectInputStream(socket.getInputStream())) {

            console.println("Подключено к серверу: " + host + ":" + port);

            while (true) {
                console.println("Введите команду: ");
                String command = console.read().trim();
                Object argument = null;

                if (command.equals("exit")) {
                    output.writeObject(command);
                    output.writeObject(null);
                    output.writeObject(userId);
                    break;
                }

                String[] parts = command.split("\\s+", 2);
                String commandName = parts[0].toLowerCase();

                if (commandName.equals("delete_user")) {
                    if (userId == null) {
                        console.println("Ошибка: необходимо авторизоваться");
                        continue;
                    }
                    output.writeObject("get_users");
                    output.writeObject(null);
                    output.writeObject(userId);
                    output.flush();

                    ExecutionResponse response = (ExecutionResponse) input.readObject();
                    if (!response.isSuccess()) {
                        console.println("Ошибка при получении списка пользователей: " + response.getMessage());
                        continue;
                    }

                    String[] usersList = response.getMessage().split("\n");
                    users.clear();
                    for (String user : usersList) {
                        if (!user.trim().isEmpty()) {
                            users.add(user.trim());
                        }
                    }

                    if (users.isEmpty()) {
                        console.println("Список пользователей пуст");
                        continue;
                    }

                    console.println("Список пользователей:");
                    for (int i = 0; i < users.size(); i++) {
                        console.println((i + 1) + ". " + users.get(i));
                    }

                    console.println("Введите номер пользователя для удаления:");
                    String inputStr = console.read().trim();
                    int userNumber;
                    try {
                        userNumber = Integer.parseInt(inputStr);
                        if (userNumber < 1 || userNumber > users.size()) {
                            console.println("Ошибка: неверный номер пользователя");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректный номер");
                        continue;
                    }

                    String usernameToDelete = users.get(userNumber - 1);
                    console.println("Вы уверены, что хотите удалить пользователя " + usernameToDelete + "? (да/нет)");
                    String confirmation = console.read().trim().toLowerCase();
                    if (!confirmation.equals("да")) {
                        console.println("Удаление отменено");
                        continue;
                    }

                    users.remove(userNumber - 1);
                    console.println("Пользователь " + usernameToDelete + " успешно удален");
                    continue;
                }

                if (commandName.equals("register") || commandName.equals("login")) {
                    console.println("Введите имя пользователя (не пустое):");
                    String username = console.read().trim();
                    if (username.isEmpty()) {
                        console.println("Ошибка: имя пользователя не может быть пустым");
                        continue;
                    }

                    console.println("Введите пароль (не пустой):");
                    String password = console.read().trim();
                    if (password.isEmpty()) {
                        console.println("Ошибка: пароль не может быть пустым");
                        continue;
                    }

                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(username);
                    humanBeing.setCar(new Car(password));
                    argument = humanBeing;
                } else if (commandName.equals("execute_script")) {
                    console.println("Введите путь к файлу скрипта:");
                    String scriptPath = console.read().trim();
                    if (scriptPath.isEmpty()) {
                        console.println("Ошибка: путь к файлу не может быть пустым");
                        continue;
                    }
                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(scriptPath);
                    argument = humanBeing;
                } else if (commandName.equals("removebyid")) {
                    console.println("Введите id элемента для удаления (целое положительное число):");
                    String idInput = console.read().trim();
                    Long id;
                    try {
                        id = Long.parseLong(idInput);
                        if (id <= 0) {
                            console.println("Ошибка: id должен быть положительным числом");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректное целое число для id");
                        continue;
                    }
                    argument = id;
                } else {
                    if (userId == null) {
                        console.println("Ошибка: необходимо войти в систему (login) или зарегистрироваться (register)");
                        continue;
                    }

                    if (commandName.equals("add")) {
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("update")) {
                        console.println("Введите id элемента для обновления (целое положительное число):");
                        String idInput = console.read().trim();
                        Long id;
                        try {
                            id = Long.parseLong(idInput);
                            if (id <= 0) {
                                console.println("Ошибка: id должен быть положительным числом");
                                continue;
                            }
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число для id");
                            continue;
                        }
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            humanBeing.setId(id);
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("filter_starts_with_name")) {
                        console.println("Введите имя (не пустое):");
                        String name = console.read().trim();
                        if (name.isEmpty()) {
                            console.println("Ошибка: имя не может быть пустым");
                            continue;
                        }
                        HumanBeing humanBeing = new HumanBeing();
                        humanBeing.setName(name);
                        argument = humanBeing;
                    } else if (commandName.equals("count_less_than_impact_speed")) {
                        console.println("Введите impactSpeed (целое число):");
                        String impactSpeedInput = console.read().trim();
                        try {
                            long impactSpeed = Long.parseLong(impactSpeedInput);
                            HumanBeing humanBeing = new HumanBeing();
                            humanBeing.setImpactSpeed(impactSpeed);
                            argument = humanBeing;
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число");
                            continue;
                        }
                    }
                }

                output.writeObject(commandName);
                output.writeObject(argument);
                output.writeObject(userId);
                output.flush();

                ExecutionResponse response = (ExecutionResponse) input.readObject();
                console.println("Ответ сервера: " + response.getMessage());

                if (commandName.equals("execute_script")) {
                    if (response.isSuccess()) {
                        console.println("Результат выполнения скрипта:");
                        String message = response.getMessage();
                        if (message != null && !message.isEmpty()) {
                            String[] lines = message.split("\\r?\\n");
                            for (String line : lines) {
                                console.println(line);
                            }
                        } else {
                            console.println("Пустой результат от сервера");
                        }
                    } else {
                        console.println("Ошибка выполнения скрипта: " + response.getMessage());
                    }
                }

                if ((commandName.equals("login") || commandName.equals("register")) && response.isSuccess()) {
                    try {
                        userId = Integer.parseInt(response.getMessage());
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: некорректный userId от сервера");
                    }
                }
            }
        } catch (IOException | ClassNotFoundException e) {
            console.println("Ошибка клиента: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
package main.gui;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.stage.Stage;
import main.gui.controllers.MainWindowController;

import java.util.Locale;
import java.util.ResourceBundle;

public class MainApp extends Application {
    private static Locale locale = new Locale("ru", "RU");
    private static ResourceBundle bundle = ResourceBundle.getBundle("main.gui.locale.messages", locale);

    public static Locale getLocale() { return locale; }
    public static void setLocale(Locale l) {
        locale = l;
        bundle = ResourceBundle.getBundle("main.gui.locale.messages", locale);
    }
    public static ResourceBundle getBundle() { return bundle; }

    @Override
    public void start(Stage primaryStage) throws Exception {
        showAuthWindow();
    }

    public static void showAuthWindow() throws Exception {
        FXMLLoader loader = new FXMLLoader(MainApp.class.getResource("/main/gui/views/auth.fxml"), getBundle());
        Stage stage = new Stage();
        stage.setTitle(bundle.getString("auth.title"));
        stage.setScene(new Scene(loader.load()));
        stage.show();
    }

    public static void showMainWindow(NetworkClient client, Integer userId) throws Exception {
        FXMLLoader loader = new FXMLLoader(MainApp.class.getResource("/main/gui/views/main.fxml"), getBundle());
        Stage stage = new Stage();
        stage.setTitle(bundle.getString("main.title"));
        stage.setScene(new Scene(loader.load()));
        MainWindowController controller = loader.getController();
        controller.initSession(client, userId);
        stage.show();
    }
}
package main.gui;

import utility.ExecutionResponse;

import java.io.*;
import java.net.Socket;

public class NetworkClient implements Closeable {
    private Socket socket;
    private ObjectOutputStream output;
    private ObjectInputStream input;

    public boolean connect(String host, int port) {
        try {
            socket = new Socket(host, port);
            output = new ObjectOutputStream(socket.getOutputStream());
            input = new ObjectInputStream(socket.getInputStream());
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    public ExecutionResponse sendCommand(String command, Object argument, Integer userId) {
        try {
            output.writeObject(command);
            output.writeObject(argument);
            output.writeObject(userId);
            output.flush();
            return (ExecutionResponse) input.readObject();
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка клиента: " + e.getMessage());
        }
    }

    @Override
    public void close() throws IOException {
        if (output != null) output.close();
        if (input != null) input.close();
        if (socket != null) socket.close();
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.NetworkClient;
import models.HumanBeing;
import utility.ExecutionResponse;

public class AddHumanController {
    @FXML private TextField nameField;
    @FXML private TextField impactSpeedField;
    @FXML private TextField idField; // для режима update
    @FXML private Button saveButton;
    @FXML private Label errorLabel;

    private NetworkClient networkClient;
    private Integer userId;
    private String lang;
    private Runnable reloadCallback;
    private boolean isUpdate = false;
    private Long editingId = null;

    public void init(NetworkClient networkClient, Integer userId, String lang, Runnable reloadCallback) {
        this.networkClient = networkClient;
        this.userId = userId;
        this.lang = lang;
        this.reloadCallback = reloadCallback;
        this.isUpdate = false;
        idField.setVisible(false); // скрываем id для создания
    }

    public void initForUpdate(NetworkClient networkClient, Integer userId, HumanBeing human, String lang, Runnable reloadCallback) {
        this.networkClient = networkClient;
        this.userId = userId;
        this.lang = lang;
        this.reloadCallback = reloadCallback;
        this.isUpdate = true;
        this.editingId = human.getId();
        idField.setText(String.valueOf(human.getId()));
        idField.setEditable(false);
        idField.setVisible(true);
        nameField.setText(human.getName());
        impactSpeedField.setText(human.getImpactSpeed() == null ? "" : String.valueOf(human.getImpactSpeed()));
        // Заполни остальные поля, если есть
    }

    @FXML
    private void initialize() {
        saveButton.setOnAction(event -> handleSave());
    }

    private void handleSave() {
        errorLabel.setText("");
        String name = nameField.getText().trim();
        String impactSpeedTxt = impactSpeedField.getText().trim();

        if (name.isEmpty()) {
            errorLabel.setText("Имя не может быть пустым.");
            return;
        }
        Long impactSpeed = null;
        if (!impactSpeedTxt.isEmpty()) {
            try {
                impactSpeed = Long.parseLong(impactSpeedTxt);
            } catch (NumberFormatException e) {
                errorLabel.setText("impactSpeed должен быть числом.");
                return;
            }
        }

        HumanBeing human = new HumanBeing();
        human.setName(name);
        human.setImpactSpeed(impactSpeed);

        if (isUpdate) {
            human.setId(editingId);
        }

        // Заполни остальные поля

        ExecutionResponse response = networkClient.sendCommand(isUpdate ? "update" : "add", human, userId);
        if (response.isSuccess()) {
            Stage stage = (Stage) saveButton.getScene().getWindow();
            stage.close();
            if (reloadCallback != null) reloadCallback.run();
        } else {
            errorLabel.setText(response.getMessage());
        }
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.MainApp;
import main.gui.NetworkClient;
import models.Car;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.IOException;
import java.util.Locale;

public class AuthController {
    @FXML private TextField usernameField;
    @FXML private PasswordField passwordField;
    @FXML private Button loginButton;
    @FXML private Button registerButton;
    @FXML private ComboBox<String> languageBox;
    @FXML private Label messageLabel;

    private NetworkClient networkClient;
    private Integer userId;

    private int lastLanguageIndex = -1;

    @FXML
    private void initialize() {
        languageBox.getItems().setAll("Русский", "Македонский", "Latviešu", "Español (Colombia)");
        Locale current = MainApp.getLocale();
        int idx = 0;
        if (current.getLanguage().equals("ru")) idx = 0;
        else if (current.getLanguage().equals("mk")) idx = 1;
        else if (current.getLanguage().equals("lv")) idx = 2;
        else if (current.getLanguage().equals("es")) idx = 3;
        languageBox.getSelectionModel().select(idx);
        lastLanguageIndex = idx;

        languageBox.getSelectionModel().selectedIndexProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            if (newVal.intValue() == lastLanguageIndex) return; // если язык не менялся — не перезагружаем
            lastLanguageIndex = newVal.intValue();
            switch (newVal.intValue()) {
                case 0:
                    MainApp.setLocale(new Locale("ru", "RU")); break;
                case 1:
                    MainApp.setLocale(new Locale("mk", "MK")); break;
                case 2:
                    MainApp.setLocale(new Locale("lv", "LV")); break;
                case 3:
                    MainApp.setLocale(new Locale("es", "CO")); break;
            }
            java.util.ResourceBundle.clearCache();
            reload();
        });
    }

    private void reload() {
        try {
            Stage stage = (Stage) usernameField.getScene().getWindow();
            stage.close();
            MainApp.showAuthWindow();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @FXML
    private void handleLogin(javafx.event.ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.empty"));
            return;
        }

        if (networkClient != null) {
            try { networkClient.close(); } catch (IOException ignored) {}
        }
        networkClient = new NetworkClient();
        if (!networkClient.connect("localhost", 5000)) {
            messageLabel.setText("Ошибка соединения с сервером");
            return;
        }
        HumanBeing user = new HumanBeing();
        user.setName(username);
        user.setCar(new Car(password));
        ExecutionResponse response = networkClient.sendCommand("login", user, null);
        if (response.isSuccess()) {
            try {
                userId = Integer.parseInt(response.getMessage());
                messageLabel.setText(MainApp.getBundle().getString("auth.login.success"));
                try {
                    MainApp.showMainWindow(networkClient, userId);
                    Stage stage = (Stage) loginButton.getScene().getWindow();
                    stage.close();
                } catch (Exception e) {
                    e.printStackTrace();
                    messageLabel.setText("Ошибка открытия главного окна: " + e.getMessage());
                }
            } catch (NumberFormatException e) {
                messageLabel.setText("Некорректный userId от сервера");
                try { networkClient.close(); } catch (IOException ignored) {}
            }
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.fail") + " " + response.getMessage());
            try { networkClient.close(); } catch (IOException ignored) {}
        }
    }

    @FXML
    private void handleRegister(javafx.event.ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.empty"));
            return;
        }

        if (networkClient != null) {
            try { networkClient.close(); } catch (IOException ignored) {}
        }
        networkClient = new NetworkClient();
        if (!networkClient.connect("localhost", 5000)) {
            messageLabel.setText("Ошибка соединения с сервером");
            return;
        }
        HumanBeing user = new HumanBeing();
        user.setName(username);
        user.setCar(new Car(password));
        ExecutionResponse response = networkClient.sendCommand("register", user, null);
        if (response.isSuccess()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.success"));
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.fail") + " " + response.getMessage());
            try { networkClient.close(); } catch (IOException ignored) {}
        }
    }

    public NetworkClient getNetworkClient() {
        return networkClient;
    }
    public Integer getUserId() {
        return userId;
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;

public class MainController {
    @FXML private Label userLabel;
    @FXML private TableView<?> tableView; // замените ? на вашу модель
    @FXML private Canvas canvas;

    @FXML
    private void initialize() {
        userLabel.setText("User: ...");
        // Настройка TableView, загрузка данных с сервера
    }

    @FXML
    private void handleCanvasClick(MouseEvent event) {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        // TODO: обработка клика, выделение объекта, вывод информации
    }

    // Добавьте методы для фильтрации, сортировки, обновления таблицы, работы с графикой и т.д.
}
package main.gui.controllers;

import javafx.collections.FXCollections;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.MainApp;
import main.gui.NetworkClient;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

public class MainWindowController {
    @FXML private ComboBox<String> languageBox;
    @FXML private ListView<String> commandListView;
    @FXML private Label commandTitle;
    @FXML private TextArea commandOutput;
    @FXML private Button executeButton;
    @FXML private TextField argumentField;
    @FXML private Button registerButton;
    @FXML private Button exitButton;

    private NetworkClient networkClient;
    private Integer userId;

    private final List<String> commands = Arrays.asList(
            "add", "update", "remove_head", "clear", "info", "show",
            "help", "filter_starts_with_name", "print_unique_impact_speed",
            "count_less_than_impact_speed", "execute_script", "removebyid"
    );

    private int lastLanguageIndex = -1;

    public void initSession(NetworkClient networkClient, Integer userId) {
        this.networkClient = networkClient;
        this.userId = userId;
        List<String> visibleCommands = commands.stream()
                .filter(cmd -> !cmd.equals("login") && !cmd.equals("register"))
                .collect(Collectors.toList());
        commandListView.setItems(FXCollections.observableArrayList(visibleCommands));
    }

    @FXML
    private void initialize() {
        languageBox.getItems().setAll("Русский", "Македонский", "Latviešu", "Español (Colombia)");
        Locale current = MainApp.getLocale();
        int idx = 0;
        if (current.getLanguage().equals("ru")) idx = 0;
        else if (current.getLanguage().equals("mk")) idx = 1;
        else if (current.getLanguage().equals("lv")) idx = 2;
        else if (current.getLanguage().equals("es")) idx = 3;
        languageBox.getSelectionModel().select(idx);
        lastLanguageIndex = idx;

        languageBox.getSelectionModel().selectedIndexProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            if (newVal.intValue() == lastLanguageIndex) return;
            lastLanguageIndex = newVal.intValue();
            switch (newVal.intValue()) {
                case 0:
                    MainApp.setLocale(new Locale("ru", "RU")); break;
                case 1:
                    MainApp.setLocale(new Locale("mk", "MK")); break;
                case 2:
                    MainApp.setLocale(new Locale("lv", "LV")); break;
                case 3:
                    MainApp.setLocale(new Locale("es", "CO")); break;
            }
            java.util.ResourceBundle.clearCache();
            reload();
        });

        commandListView.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            commandTitle.setText(newVal == null ? "" : newVal);
            commandOutput.clear();
            argumentField.clear();
        });
        commandListView.getSelectionModel().selectFirst();

        executeButton.setOnAction(event -> executeSelectedCommand());
        argumentField.setOnAction(event -> executeSelectedCommand());
        registerButton.setOnAction(event -> goToRegister());
        exitButton.setOnAction(event -> exitApp());
    }

    private void executeSelectedCommand() {
        String command = commandListView.getSelectionModel().getSelectedItem();
        if (command == null) return;
        String arg = argumentField.getText().trim();
        Object argument = null;

        try {
            switch (command) {
                case "add":
                    openAddHumanDialog(null); // режим создания
                    return;
                case "update":
                    if (arg.isEmpty()) {
                        commandOutput.setText("Ошибка: необходимо указать id для обновления.");
                        return;
                    }
                    try {
                        Long id = Long.parseLong(arg);
                        // Запросить с сервера объект с этим id
                        ExecutionResponse getResp = networkClient.sendCommand("get_by_id", id, userId);
                        if (!getResp.isSuccess() || getResp.getHumanBeing() == null) {
                            commandOutput.setText("Элемент не найден или не принадлежит вам.");
                            return;
                        }
                        // Открываем окно редактирования с уже заполненными данными
                        openAddHumanDialog(getResp.getHumanBeing()); // режим редактирования
                    } catch (NumberFormatException e) {
                        commandOutput.setText("Ошибка: id должен быть числом.");
                    }
                    return;
                case "removebyid":
                    if (arg.isEmpty()) {
                        commandOutput.setText("Ошибка: необходимо указать id.");
                        return;
                    }
                    try {
                        Long id = Long.parseLong(arg);
                        HumanBeing removeHuman = new HumanBeing();
                        removeHuman.setId(id);
                        argument = removeHuman;
                    } catch (NumberFormatException e) {
                        commandOutput.setText("Ошибка: id должен быть числом.");
                        return;
                    }
                    break;
                case "count_less_than_impact_speed":
                    if (arg.isEmpty()) {
                        commandOutput.setText("Ошибка: необходимо указать значение impactSpeed.");
                        return;
                    }
                    try {
                        long impactSpeed = Long.parseLong(arg);
                        HumanBeing countHuman = new HumanBeing();
                        countHuman.setImpactSpeed(impactSpeed);
                        argument = countHuman;
                    } catch (NumberFormatException e) {
                        commandOutput.setText("Ошибка: impactSpeed должен быть числом.");
                        return;
                    }
                    break;
                case "filter_starts_with_name":
                    if (arg.isEmpty()) {
                        commandOutput.setText("Ошибка: необходимо указать подстроку для поля name.");
                        return;
                    }
                    HumanBeing filterHuman = new HumanBeing();
                    filterHuman.setName(arg);
                    argument = filterHuman;
                    break;
                case "execute_script":
                    if (arg.isEmpty()) {
                        commandOutput.setText("Ошибка: требуется путь к файлу скрипта.");
                        return;
                    }
                    HumanBeing scriptHuman = new HumanBeing();
                    scriptHuman.setName(arg);
                    argument = scriptHuman;
                    break;
                default:
                    argument = null;
            }
        } catch (Exception e) {
            commandOutput.setText("Ошибка: " + e.getMessage());
            return;
        }

        // Для help/info/show/clear — передаём объект HumanBeing с языком
        if (command.equals("help") || command.equals("info") || command.equals("show") || command.equals("clear")) {
            String currentLang = MainApp.getLocale().getLanguage();
            HumanBeing langArg = new HumanBeing();
            langArg.setName(currentLang);
            ExecutionResponse response = networkClient.sendCommand(command, langArg, userId);

            if ("help".equals(command)) {
                String filtered = Arrays.stream(response.getMessage().split("\\r?\\n"))
                        .filter(line -> !line.trim().startsWith("login") && !line.trim().startsWith("register"))
                        .collect(Collectors.joining("\n"));
                commandOutput.setText(filtered);
            } else {
                commandOutput.setText(response.getMessage());
            }
        } else {
            ExecutionResponse response = networkClient.sendCommand(command, argument, userId);
            commandOutput.setText(response.getMessage());
        }
    }

    private void openAddHumanDialog(HumanBeing humanBeing) {
        try {
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/main/gui/views/add_human.fxml"));
            Parent root = loader.load();
            AddHumanController controller = loader.getController();
            if (humanBeing == null) {
                controller.init(networkClient, userId, MainApp.getLocale().getLanguage(), this::reload);
            } else {
                controller.initForUpdate(networkClient, userId, humanBeing, MainApp.getLocale().getLanguage(), this::reload);
            }

            Stage stage = new Stage();
            stage.setTitle(humanBeing == null ? "Добавить HumanBeing" : "Редактировать HumanBeing");
            stage.setScene(new Scene(root));
            stage.initOwner(executeButton.getScene().getWindow());
            stage.showAndWait();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void goToRegister() {
        try {
            if (networkClient != null) {
                networkClient.close();
            }
        } catch (IOException ignored) {}
        try {
            Stage stage = (Stage) registerButton.getScene().getWindow();
            stage.close();
            MainApp.showAuthWindow();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void exitApp() {
        try {
            networkClient.sendCommand("exit", null, userId);
            networkClient.close();
        } catch (IOException ignored) {}
        Stage stage = (Stage) exitButton.getScene().getWindow();
        stage.close();
    }

    private void reload() {
        try {
            Stage stage = (Stage) languageBox.getScene().getWindow();
            NetworkClient oldClient = this.networkClient;
            Integer oldUserId = this.userId;
            stage.close();
            MainApp.showMainWindow(oldClient, oldUserId);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return "HumanBeing{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", coordinates=" + coordinates +
                ", creationDate=" + creationDate +
                ", realHero=" + realHero +
                ", hasToothpick=" + hasToothpick +
                ", impactSpeed=" + impactSpeed +
                ", weaponType=" + weaponType +
                ", mood=" + mood +
                ", car=" + car +
                ", userId=" + userId +
                '}';
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;

public class ExecutionResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private final boolean success;
    private final String message;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        humanBeing.setCoordinates(new Coordinates(x, y));

        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood mood = Mood.valueOf(moodInput.toUpperCase());
                humanBeing.setMood(mood.toString());
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;

public class Request implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.time.LocalDateTime;
import java.util.Locale;
import java.util.ResourceBundle;

public class Add extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Add(Console console, CollectionManager collectionManager) {
        super("add", "добавить новый элемент в коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().isEmpty())
            lang = argument.getName();
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("add.error.not_authorized"));
        }

        if (argument == null) {
            return new ExecutionResponse(false, bundle.getString("add.error.no_argument"));
        }

        argument.setUserId(userId);
        argument.setCreationDate(LocalDateTime.now());
        collectionManager.add(argument, userId); // <-- так правильно

        return new ExecutionResponse(true, bundle.getString("add.success"));
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.Locale;
import java.util.ResourceBundle;

public class Clear extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Clear(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("clear", "очистить коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: clear, userId: " + userId);

        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("clear.error.not_authorized"));
        }

        boolean success = collectionManager.clear(userId);
        if (success) {
            return new ExecutionResponse(true, bundle.getString("clear.success") + " " + userId);
        } else {
            return new ExecutionResponse(false, bundle.getString("clear.error.failed"));
        }
    }
}
package commands;

import models.HumanBeing;
import utility.ExecutionResponse;

public abstract class Command {
    protected String name;
    protected String description;

    public Command(String name, String description) {
        this.name = name;
        this.description = description;
    }

    public abstract ExecutionResponse execute(HumanBeing argument, Integer userId);

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class CountLessThanImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public CountLessThanImpactSpeed(Console console, CollectionManager collectionManager) {
        super("count_less_than_impact_speed", "вывести количество элементов, значение поля impactSpeed которых меньше заданного");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: count_less_than_impact_speed, userId: " + userId);
        if (argument == null || argument.getImpactSpeed() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать значение impactSpeed");
        }

        long threshold = argument.getImpactSpeed();
        long count = collectionManager.getCollection().stream()
                .filter(h -> h.getUserId().equals(userId))
                .filter(h -> h.getImpactSpeed() < threshold)
                .count();

        return new ExecutionResponse(true, "Количество элементов с impactSpeed меньше " + threshold + ": " + count);
    }
}
package commands;

import models.HumanBeing;
import models.Coordinates;
import models.Car;
import models.WeaponType;
import models.Mood;
import utility.Console;
import utility.ExecutionResponse;
import managers.CommandManager;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;

public class ExecuteScript extends Command {
    private final Console console;
    private final CommandManager commandManager;
    private final Set<String> executedFiles = new HashSet<>();
    private final List<String> inputLines = new ArrayList<>();

    public ExecuteScript(Console console, CommandManager commandManager) {
        super("execute_script", "исполнить скрипт из файла");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || humanBeing.getName() == null || humanBeing.getName().trim().isEmpty()) {
            return new ExecutionResponse(false, "Требуется путь к файлу скрипта");
        }

        String scriptPath = humanBeing.getName().trim();

        try {
            String absolutePath = Paths.get(scriptPath).toAbsolutePath().toString();

            if (executedFiles.contains(absolutePath)) {
                return new ExecutionResponse(false, "Обнаружена рекурсия: файл " + scriptPath + " уже выполняется");
            }

            executedFiles.add(absolutePath);
            StringBuilder scriptOutput = new StringBuilder();

            try (BufferedReader reader = new BufferedReader(new FileReader(absolutePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith("#")) continue;

                    String[] parts = line.split("\\s+", 2);
                    String commandName = parts[0].toLowerCase();
                    HumanBeing commandHumanBeing = new HumanBeing();

                    if (commandName.equals("execute_script")) {
                        commandHumanBeing.setName(parts.length > 1 ? parts[1] : "");
                    } else if (commandName.equals("add") || commandName.equals("update")) {
                        // Читаем следующие 9 строк для команды add/update
                        inputLines.clear();
                        for (int i = 0; i < 9; i++) {
                            String nextLine = reader.readLine();
                            if (nextLine == null) {
                                return new ExecutionResponse(false, "Неожиданный конец файла при чтении параметров команды " + commandName);
                            }
                            nextLine = nextLine.trim();
                            if (nextLine.isEmpty()) {
                                i--; // Пропускаем пустые строки
                                continue;
                            }
                            inputLines.add(nextLine);
                        }
                        // Устанавливаем параметры в объект HumanBeing в правильном порядке
                        if (inputLines.size() >= 1) commandHumanBeing.setName(inputLines.get(0));
                        if (inputLines.size() >= 3) {
                            try {
                                double x = Double.parseDouble(inputLines.get(1));
                                float y = Float.parseFloat(inputLines.get(2));
                                commandHumanBeing.setCoordinates(new Coordinates(x, y));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении координат: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 4) commandHumanBeing.setRealHero(Boolean.parseBoolean(inputLines.get(3)));
                        if (inputLines.size() >= 5) commandHumanBeing.setHasToothpick(Boolean.parseBoolean(inputLines.get(4)));
                        if (inputLines.size() >= 6) {
                            try {
                                commandHumanBeing.setImpactSpeed(Long.parseLong(inputLines.get(5)));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении impactSpeed: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 7) {
                            try {
                                commandHumanBeing.setWeaponType(WeaponType.valueOf(inputLines.get(6)));
                            } catch (IllegalArgumentException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении weaponType: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 8) commandHumanBeing.setMood(inputLines.get(7));
                        if (inputLines.size() >= 9) {
                            String carName = inputLines.get(8);
                            commandHumanBeing.setCar(new Car(carName));
                        }
                        // Устанавливаем дату создания для команды add
                        if (commandName.equals("add")) {
                            commandHumanBeing.setCreationDate(LocalDateTime.now());
                        }
                    } else if (commandName.equals("removebyid")) {
                        if (parts.length > 1) {
                            try {
                                commandHumanBeing.setId(Long.parseLong(parts[1]));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка: ID должен быть числом");
                            }
                        }
                    } else if (parts.length > 1) {
                        commandHumanBeing.setName(parts[1]);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, commandHumanBeing, userId);
                    scriptOutput.append(response.getMessage()).append("\n");
                }
            } finally {
                executedFiles.remove(absolutePath);
            }

            return new ExecutionResponse(true, scriptOutput.toString().trim());
        } catch (IOException e) {
            return new ExecutionResponse(false, "Ошибка при чтении файла: " + e.getMessage());
        }
    }
}
package commands;

import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Exit extends Command {
    private final Console console;

    public Exit(Console console) {
        super("exit", "завершить работу клиента");
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Завершение работы клиента");
        return new ExecutionResponse(true, "Клиент отключен");
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class FilterStartsWithName extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public FilterStartsWithName(Console console, CollectionManager collectionManager) {
        super("filter_starts_with_name", "вывести элементы, значение поля name которых начинается с заданной подстроки");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: filter_starts_with_name, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }
        if (argument == null || argument.getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать подстроку для поля name");
        }

        String prefix = argument.getName();
        console.println("Ищем элементы с именем, начинающимся с: " + prefix);
        
        StringBuilder response = new StringBuilder("Элементы с именем, начинающимся с \"" + prefix + "\":\n");
        boolean found = false;
        int totalElements = 0;
        int matchingElements = 0;

        for (HumanBeing human : collectionManager.getCollection()) {
            totalElements++;
            console.println("Проверяем элемент: " + human.getName() + " (userId: " + human.getUserId() + ")");
            if (human.getName().startsWith(prefix) && human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                matchingElements++;
            }
        }

        console.println("Всего элементов в коллекции: " + totalElements);
        console.println("Найдено совпадающих элементов: " + matchingElements);

        if (!found) {
            response.append("Элементы не найдены.");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CommandManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.Locale;
import java.util.ResourceBundle;

public class Help extends Command {
    private final Console console;
    private final CommandManager commandManager;

    public Help(Console console, CommandManager commandManager) {
        super("help", "вывести справку по доступным командам");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        Locale locale = new Locale(lang);

        ResourceBundle bundle; // <-- объявляем тут!ф
        try {
            bundle = ResourceBundle.getBundle("messages", locale);
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        StringBuilder response = new StringBuilder(
                bundle.containsKey("help.title")
                        ? bundle.getString("help.title") + "\n"
                        : "Доступные команды:\n"
        );

        for (var entry : commandManager.getCommands().entrySet()) {
            String name = entry.getKey();
            Command command = entry.getValue();
            String key = "help." + name;
            String description = bundle.containsKey(key)
                    ? bundle.getString(key)
                    : command.getDescription();
            response.append(name).append(": ").append(description).append("\n");
        }
        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;

public class Info extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Info(Console console, CollectionManager collectionManager) {
        super("info", "вывести информацию о коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: info, userId: " + userId);

        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("info.error.not_authorized"));
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        int totalElements = collection.size();
        int userElements = 0;
        for (HumanBeing human : collection) {
            if (human.getUserId().equals(userId)) userElements++;
        }

        StringBuilder response = new StringBuilder();
        response.append(bundle.getString("info.type")).append(" ").append(collection.getClass().getSimpleName()).append("\n");
        response.append(bundle.getString("info.init_date")).append(" ").append(collectionManager.getInitializationDate()).append("\n");
        response.append(bundle.getString("info.total_elements")).append(" ").append(totalElements).append("\n");
        response.append(bundle.getString("info.user_elements")).append(" ").append(userElements);

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Login extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Login(DatabaseManager dbManager, Console console) {
        super("login", "авторизоваться с существующим пользователем");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: login, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: " + "необходимо указать имя пользователя и пароль");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка авторизации: username=" + username);
        Integer resultId = dbManager.loginUser(username, password);
        if (resultId != null) {
            return new ExecutionResponse(true, String.valueOf(resultId));
        } else {
            return new ExecutionResponse(false, "Ошибка авторизации: неверный username или password");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashSet;
import java.util.Set;

public class PrintUniqueImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public PrintUniqueImpactSpeed(Console console, CollectionManager collectionManager) {
        super("print_unique_impact_speed", "вывести уникальные значения поля impactSpeed");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: print_unique_impact_speed, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        Set<Long> uniqueSpeeds = new HashSet<>();
        for (HumanBeing human : collectionManager.getCollection()) {
            if (human.getUserId().equals(userId)) {
                uniqueSpeeds.add(human.getImpactSpeed());
            }
        }

        if (uniqueSpeeds.isEmpty()) {
            return new ExecutionResponse(true, "У вас нет элементов в коллекции.");
        }

        StringBuilder response = new StringBuilder("Уникальные значения impactSpeed:\n");
        for (Long speed : uniqueSpeeds) {
            response.append(speed).append("\n");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Register extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Register(DatabaseManager dbManager, Console console) {
        super("register", "зарегистрировать нового пользователя");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: register, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать username и password");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка регистрации: username=" + username);

        Integer newUserId = dbManager.registerUser(username, password);
        if (newUserId != null) {
            return new ExecutionResponse(true, String.valueOf(newUserId));
        } else {
            return new ExecutionResponse(false, "Ошибка регистрации: пользователь уже существует или неверные данные");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class RemoveById extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveById(Console console, CollectionManager collectionManager) {
        super("removebyid", "удалить элемент из коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: removebyid, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }
        if (argument == null || argument.getId() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать id для удаления");
        }

        Long id = argument.getId();
        // Debug: Print collection contents
        console.println("Содержимое коллекции перед удалением id=" + id + ":");
        for (Long key : collectionManager.getCollectionMap().keySet()) {
            HumanBeing hb = collectionManager.getCollectionMap().get(key);
            console.println("id=" + hb.getId() + ", userId=" + hb.getUserId());
        }

        HumanBeing humanBeing = collectionManager.getCollectionMap().get(id);
        if (humanBeing == null) {
            console.println("Элемент с id " + id + " не найден в коллекции");
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " не существует в коллекции");
        }
        if (!humanBeing.getUserId().equals(userId)) {
            console.println("Элемент с id " + id + " принадлежит userId=" + humanBeing.getUserId());
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " принадлежит другому пользователю");
        }

        boolean success = collectionManager.remove(id, userId);
        if (success) {
            console.println("Элемент с id " + id + " успешно удален");
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно удален");
        } else {
            console.println("Ошибка удаления id=" + id + " из базы данных");
            return new ExecutionResponse(false, "Ошибка при удалении элемента с id " + id + ": не удалось удалить из базы данных");
        }
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;

public class RemoveHead extends Command {
    private final CollectionManager collectionManager;
    private final DatabaseManager databaseManager;
    private final Console console;

    public RemoveHead(CollectionManager collection, Console console, DatabaseManager databaseManager) {
        super("remove_head", "вывести и удалить первый элемент коллекции");
        this.collectionManager = collection;
        this.databaseManager = databaseManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: remove_head, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        if (collection.isEmpty()) {
            return new ExecutionResponse(false, "Коллекция пуста");
        }

        HumanBeing head = collection.stream()
                .filter(h -> h.getUserId().equals(userId))
                .findFirst()
                .orElse(null);

        if (head == null) {
            return new ExecutionResponse(false, "Нет элементов, принадлежащих пользователю с ID " + userId);
        }

        boolean success = collectionManager.remove(head.getId(), userId);
        if (success) {
            return new ExecutionResponse(true, "Первый элемент: " + head.toString() + "\nЭлемент успешно удален");
        } else {
            return new ExecutionResponse(false, "Ошибка при удалении первого элемента");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;

public class Show extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Show(Console console, CollectionManager collectionManager) {
        super("show", "вывести все элементы коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: show, userId: " + userId);

        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("show.error.not_authorized"));
        }

        StringBuilder response = new StringBuilder(bundle.getString("show.header") + "\n");
        List<HumanBeing> collection = collectionManager.getCollection();
        boolean found = false;
        int totalElements = 0;
        int userElements = 0;

        for (HumanBeing human : collection) {
            totalElements++;
            if (human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                userElements++;
            }
        }

        console.println(bundle.getString("show.console.total") + totalElements);
        console.println(bundle.getString("show.console.user") + userElements);

        if (!found) {
            response.append(bundle.getString("show.no_elements"));
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Update extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Update(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("update", "обновить элемент коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        console.println("Выполняется команда: update, userId: " + userId);
        
        if (humanBeing == null) {
            return new ExecutionResponse(false, "Ошибка: объект HumanBeing не предоставлен");
        }
        
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        Long id = humanBeing.getId();
        if (id == null) {
            return new ExecutionResponse(false, "Ошибка: id не указан");
        }
        
        if (id <= 0) {
            return new ExecutionResponse(false, "Ошибка: id должен быть положительным числом");
        }

        // Check if the element exists and belongs to the user
        HumanBeing existingHuman = collectionManager.getCollectionMap().get(id);
        if (existingHuman == null) {
            return new ExecutionResponse(false, "Ошибка: элемент с указанным id не найден");
        }

        if (!existingHuman.getUserId().equals(userId)) {
            return new ExecutionResponse(false, "Ошибка: вы не можете изменить элемент, созданный другим пользователем");
        }

        // Update the element
        boolean success = collectionManager.update(id, humanBeing, userId);
        if (success) {
            return new ExecutionResponse(true, "Элемент успешно обновлен");
        } else {
            return new ExecutionResponse(false, "Ошибка при обновлении элемента");
        }
    }
}
package main;

import managers.CollectionManager;
import managers.CommandManager;
import managers.DatabaseManager;
import server.Server;
import utility.Console;
import utility.StandardConsole;

public class ServerMain {
    public static void main(String[] args) {
        Console console = new StandardConsole();
        DatabaseManager databaseManager = new DatabaseManager();
        CollectionManager collectionManager = new CollectionManager(databaseManager);
        CommandManager commandManager = new CommandManager(console, collectionManager, databaseManager);
        Server server = new Server(5000, commandManager);
        server.run();
    }
}
package managers;

import models.HumanBeing;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CollectionManager {
    private final Map<Long, HumanBeing> collection;
    private final DatabaseManager dbManager;
    private final LocalDateTime initializationDate;

    public CollectionManager(DatabaseManager dbManager) {
        this.collection = new ConcurrentHashMap<>();
        this.dbManager = dbManager;
        this.initializationDate = LocalDateTime.now();
    }

    public List<HumanBeing> getCollection() {
        return dbManager.loadHumanBeings();
    }

    public LocalDateTime getInitializationDate() {
        return initializationDate;
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || userId == null) {
            return false;
        }
        if (dbManager.add(humanBeing, userId)) {
            collection.put(humanBeing.getId(), humanBeing);
            return true;
        }
        return false;
    }

    public boolean update(Long id, HumanBeing humanBeing, Integer userId) {
        return dbManager.updateHumanBeing(id, humanBeing, userId);
    }

    public boolean remove(Long id, Integer userId) {
        return dbManager.removeHumanBeing(id, userId);
    }

    public boolean clear(Integer userId) {
        return dbManager.clearHumanBeings(userId);
    }

    public Map<Long, HumanBeing> getCollectionMap() {
        return collection;
    }
}
package managers;

import commands.*;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashMap;
import java.util.Map;

public class CommandManager {
    private final Map<String, Command> commands = new HashMap<>();
    private final Console console;

    public CommandManager(Console console, CollectionManager collectionManager, DatabaseManager databaseManager) {
        this.console = console;
        commands.put("add", new Add(console, collectionManager));
        commands.put("update", new Update(console, collectionManager, databaseManager));
        commands.put("remove_head", new RemoveHead(collectionManager, console, databaseManager));
        commands.put("clear", new Clear(console, collectionManager, databaseManager));
        commands.put("info", new Info(console, collectionManager));
        commands.put("show", new Show(console, collectionManager));
        commands.put("login", new Login(databaseManager, console));
        commands.put("register", new Register(databaseManager, console));
        commands.put("exit", new Exit(console));
        commands.put("help", new Help(console, this));
        commands.put("filter_starts_with_name", new FilterStartsWithName(console, collectionManager));
        commands.put("print_unique_impact_speed", new PrintUniqueImpactSpeed(console, collectionManager));
        commands.put("count_less_than_impact_speed", new CountLessThanImpactSpeed(console, collectionManager));
        commands.put("execute_script", new ExecuteScript(console, this));
        commands.put("removebyid", new RemoveById(console, collectionManager));
    }

    public ExecutionResponse executeCommand(String commandName, HumanBeing humanBeing, Integer userId) {
        Command command = commands.get(commandName);
        if (command == null) {
            return new ExecutionResponse(false, "Команда '" + commandName + "' не найдена. Введите 'help' для списка команд.");
        }
        return command.execute(humanBeing, userId);
    }

    public Map<String, Command> getCommands() {
        return commands;
    }
}
package managers;

import models.*;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class DatabaseManager {
    private final String url = "jdbc:postgresql://localhost:5432/studs";
    private final String user = "s434931";
    private final String password = "250806";
    private Connection connection;
    private final Map<Long, HumanBeing> collection;

    public DatabaseManager() {
        this.collection = new ConcurrentHashMap<>();
        connect();
        loadHumanBeings();
    }

    private void connect() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
            }
            connection = DriverManager.getConnection(url, user, password);
            System.out.println("Подключение к базе данных установлено: " + url);
        } catch (SQLException e) {
            System.err.println("Ошибка подключения к базе данных: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void close() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                System.out.println("Соединение с базой данных закрыто");
            }
        } catch (SQLException e) {
            System.err.println("Ошибка при закрытии соединения с базой данных: " + e.getMessage());
        }
    }

    public Map<Long, HumanBeing> getCollection() {
        return collection;
    }

    public List<HumanBeing> loadHumanBeings() {
        collection.clear();
        List<HumanBeing> humans = new ArrayList<>();
        String query = "SELECT * FROM human_beings";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            while (rs.next()) {
                HumanBeing human = new HumanBeing();
                human.setId(rs.getLong("id"));
                human.setName(rs.getString("name"));
                human.setCoordinates(new Coordinates(
                        rs.getDouble("coordinate_x"),
                        rs.getFloat("coordinate_y")
                ));
                human.setCreationDate(rs.getTimestamp("creation_date").toLocalDateTime());
                human.setRealHero(rs.getBoolean("real_hero"));
                human.setHasToothpick(rs.getObject("has_toothpick") != null ? rs.getBoolean("has_toothpick") : null);
                human.setImpactSpeed(rs.getLong("impact_speed"));
                human.setWeaponType(WeaponType.valueOf(rs.getString("weapon_type")));
                human.setMood(rs.getString("mood"));
                human.setCar(new Car(rs.getString("car_name")));
                human.setUserId(rs.getInt("user_id"));
                collection.put(human.getId(), human);
                humans.add(human);
            }
            System.out.println("Коллекция загружена из базы данных: " + collection.size() + " элементов");
            return humans;
        } catch (SQLException e) {
            System.err.println("Ошибка загрузки коллекции: " + e.getMessage());
            return humans;
        }
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        String sql = "INSERT INTO human_beings (name, coordinate_x, coordinate_y, creation_date, impact_speed, real_hero, has_toothpick, weapon_type, mood, car_name, user_id) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setInt(11, userId);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    long id = rs.getLong(1);
                    humanBeing.setId(id);
                    return true;
                }
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка при добавлении элемента: " + e.getMessage());
            return false;
        }
    }

    public boolean removeHumanBeing(Long id, Integer userId) {
        if (id == null || userId == null) return false;
        String query = "DELETE FROM human_beings WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setLong(1, id);
            pstmt.setInt(2, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.remove(id);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка удаления: " + e.getMessage());
            return false;
        }
    }

    public boolean updateHumanBeing(Long id, HumanBeing humanBeing, Integer userId) {
        if (id == null || humanBeing == null || userId == null) return false;
        String query = "UPDATE human_beings SET name = ?, coordinate_x = ?, coordinate_y = ?, creation_date = ?, impact_speed = ?, real_hero = ?, has_toothpick = ?, weapon_type = ?, mood = ?, car_name = ? WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setLong(11, id);
            pstmt.setInt(12, userId);

            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                humanBeing.setId(id);
                humanBeing.setUserId(userId);
                collection.put(id, humanBeing);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка обновления: " + e.getMessage());
            return false;
        }
    }

    public boolean clearHumanBeings(Integer userId) {
        if (userId == null) return false;
        String query = "DELETE FROM human_beings WHERE user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setInt(1, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.entrySet().removeIf(entry -> entry.getValue().getUserId().equals(userId));
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка очистки: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    public Integer loginUser(String username, String password) {
        String query = "SELECT id, password FROM users WHERE username = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, username);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                String storedPassword = rs.getString("password");
                String hashedInputPassword = hashPassword(password);
                if (hashedInputPassword.equals(storedPassword)) {
                    return rs.getInt("id");
                }
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка авторизации: " + e.getMessage());
            return null;
        }
    }

    public Integer registerUser(String username, String password) {
        String query = "INSERT INTO users (username, password) VALUES (?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            String hashedPassword = hashPassword(password);
            System.out.println("Debug - Registration:");
            System.out.println("Username: " + username);
            System.out.println("Password: " + password);
            System.out.println("Hashed password: " + hashedPassword);
            pstmt.setString(1, username);
            pstmt.setString(2, hashedPassword);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt("id");
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка регистрации: " + e.getMessage());
            return null;
        }
    }

    private String hashPassword(String password) {
        int hash = password.hashCode();
        hash = hash * 31 + "SALT".hashCode();
        hash = hash * 31 + password.length();
        return String.format("%d", hash);
    }
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return String.format("(x=%.2f, y=%.2f)", x, y);
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return String.format("HumanBeing{id=%d, name='%s', coordinates=%s, creationDate=%s, realHero=%b, hasToothpick=%s, impactSpeed=%d, weaponType=%s, mood=%s, car=%s, userId=%d}",
                id, name, coordinates, creationDate, realHero, hasToothpick, impactSpeed, weaponType, mood, car, userId);
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package server;

import managers.CommandManager;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    private final int port;
    private final CommandManager commandManager;

    public Server(int port, CommandManager commandManager) {
        this.port = port;
        this.commandManager = commandManager;
    }

    public void run() {
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Сервер запущен на порту " + port);
            while (true) {
                try (Socket clientSocket = serverSocket.accept()) {
                    System.out.println("Клиент подключен: " + clientSocket.getInetAddress());
                    handleClient(clientSocket);
                } catch (Exception e) {
                    System.out.println("Ошибка обработки клиента: " + e.getMessage());
                    e.printStackTrace();
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка сервера: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleClient(Socket clientSocket) throws IOException {
        try (ObjectInputStream input = new ObjectInputStream(clientSocket.getInputStream());
             ObjectOutputStream output = new ObjectOutputStream(clientSocket.getOutputStream())) {

            while (!clientSocket.isClosed()) {
                try {
                    String commandName = (String) input.readObject();
                    Object argument = input.readObject();
                    Integer userId = (Integer) input.readObject();

                    System.out.println("Получен запрос: command=" + commandName + ", userId=" + userId);
                    if (argument != null) {
                        if (argument instanceof HumanBeing) {
                            System.out.println("Аргумент: " + ((HumanBeing) argument).getName());
                        } else if (argument instanceof Long) {
                            System.out.println("Аргумент: id=" + argument);
                        } else {
                            System.out.println("Аргумент: " + argument);
                        }
                    } else {
                        System.out.println("Аргумент: null");
                    }

                    HumanBeing humanBeing = null;
                    if (argument instanceof HumanBeing) {
                        humanBeing = (HumanBeing) argument;
                    } else if (commandName.equals("removebyid") && argument instanceof Long) {
                        humanBeing = new HumanBeing();
                        humanBeing.setId((Long) argument);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, humanBeing, userId);

                    output.writeObject(response);
                    output.flush();

                    if (commandName.equals("exit")) {
                        System.out.println("Клиент отключен: " + clientSocket.getInetAddress());
                        break;
                    }
                } catch (ClassNotFoundException e) {
                    System.err.println("Ошибка чтения данных: " + e.getMessage());
                    output.writeObject(new ExecutionResponse(false, "Ошибка чтения данных: " + e.getMessage()));
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка обработки клиента: " + e.getMessage());
            throw e;
        }
    }
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;

public class ExecutionResponse implements Serializable {
    private static final long serialVersionUID = 1L;
    private final boolean success;
    private final String message;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        // Name
        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        // Coordinate X
        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        // Coordinate Y
        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        // Устанавливаем координаты один раз после успешного ввода x и y
        humanBeing.setCoordinates(new Coordinates(x, y));

        // Real Hero
        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        // Has Toothpick
        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        // Impact Speed
        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        // Weapon Type
        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        // Mood
        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood.valueOf(moodInput.toUpperCase()); // Validate input
                humanBeing.setMood(moodInput);
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        // Car
        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        // Creation Date (set automatically)
        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;

import java.util.Locale;
import java.util.ResourceBundle;

public class LocalizationUtil {
    public static ResourceBundle getBundle(HumanBeing argument) {
        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        try {
            return ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            return ResourceBundle.getBundle("messages", new Locale("ru"));
        }
    }
}
package utility;

import models.HumanBeing;
import java.io.Serializable;

public class Request implements Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }

    @Override
    public String toString() {
        return "Request{commandName='" + commandName + "', argument=" + argument + ", userId=" + userId + "}";
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package main;

import models.Car;
import models.HumanBeing;
import models.Mood;
import models.WeaponType;
import utility.*;
import utility.Console;

import java.io.*;
import java.net.Socket;
import java.util.ArrayList;
import java.util.List;

public class ClientMain {
    private static Integer userId = null;
    private static List<String> users = new ArrayList<>();

    public static void main(String[] args) {
        String host = "localhost";
        int port = 5000;
        Console console = new StandardConsole();

        try (Socket socket = new Socket(host, port);
             ObjectOutputStream output = new ObjectOutputStream(socket.getOutputStream());
             ObjectInputStream input = new ObjectInputStream(socket.getInputStream())) {

            console.println("Подключено к серверу: " + host + ":" + port);

            while (true) {
                console.println("Введите команду: ");
                String command = console.read().trim();
                Object argument = null;

                if (command.equals("exit")) {
                    output.writeObject(command);
                    output.writeObject(null);
                    output.writeObject(userId);
                    break;
                }

                String[] parts = command.split("\\s+", 2);
                String commandName = parts[0].toLowerCase();

                if (commandName.equals("delete_user")) {
                    if (userId == null) {
                        console.println("Ошибка: необходимо авторизоваться");
                        continue;
                    }
                    output.writeObject("get_users");
                    output.writeObject(null);
                    output.writeObject(userId);
                    output.flush();

                    ExecutionResponse response = (ExecutionResponse) input.readObject();
                    if (!response.isSuccess()) {
                        console.println("Ошибка при получении списка пользователей: " + response.getMessage());
                        continue;
                    }

                    String[] usersList = response.getMessage().split("\n");
                    users.clear();
                    for (String user : usersList) {
                        if (!user.trim().isEmpty()) {
                            users.add(user.trim());
                        }
                    }

                    if (users.isEmpty()) {
                        console.println("Список пользователей пуст");
                        continue;
                    }

                    console.println("Список пользователей:");
                    for (int i = 0; i < users.size(); i++) {
                        console.println((i + 1) + ". " + users.get(i));
                    }

                    console.println("Введите номер пользователя для удаления:");
                    String inputStr = console.read().trim();
                    int userNumber;
                    try {
                        userNumber = Integer.parseInt(inputStr);
                        if (userNumber < 1 || userNumber > users.size()) {
                            console.println("Ошибка: неверный номер пользователя");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректный номер");
                        continue;
                    }

                    String usernameToDelete = users.get(userNumber - 1);
                    console.println("Вы уверены, что хотите удалить пользователя " + usernameToDelete + "? (да/нет)");
                    String confirmation = console.read().trim().toLowerCase();
                    if (!confirmation.equals("да")) {
                        console.println("Удаление отменено");
                        continue;
                    }

                    users.remove(userNumber - 1);
                    console.println("Пользователь " + usernameToDelete + " успешно удален");
                    continue;
                }

                if (commandName.equals("register") || commandName.equals("login")) {
                    console.println("Введите имя пользователя (не пустое):");
                    String username = console.read().trim();
                    if (username.isEmpty()) {
                        console.println("Ошибка: имя пользователя не может быть пустым");
                        continue;
                    }

                    console.println("Введите пароль (не пустой):");
                    String password = console.read().trim();
                    if (password.isEmpty()) {
                        console.println("Ошибка: пароль не может быть пустым");
                        continue;
                    }

                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(username);
                    humanBeing.setCar(new Car(password));
                    argument = humanBeing;
                } else if (commandName.equals("execute_script")) {
                    console.println("Введите путь к файлу скрипта:");
                    String scriptPath = console.read().trim();
                    if (scriptPath.isEmpty()) {
                        console.println("Ошибка: путь к файлу не может быть пустым");
                        continue;
                    }
                    HumanBeing humanBeing = new HumanBeing();
                    humanBeing.setName(scriptPath);
                    argument = humanBeing;
                } else if (commandName.equals("removebyid")) {
                    console.println("Введите id элемента для удаления (целое положительное число):");
                    String idInput = console.read().trim();
                    Long id;
                    try {
                        id = Long.parseLong(idInput);
                        if (id <= 0) {
                            console.println("Ошибка: id должен быть положительным числом");
                            continue;
                        }
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: введите корректное целое число для id");
                        continue;
                    }
                    argument = id;
                } else {
                    if (userId == null) {
                        console.println("Ошибка: необходимо войти в систему (login) или зарегистрироваться (register)");
                        continue;
                    }

                    if (commandName.equals("add")) {
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("update")) {
                        console.println("Введите id элемента для обновления (целое положительное число):");
                        String idInput = console.read().trim();
                        Long id;
                        try {
                            id = Long.parseLong(idInput);
                            if (id <= 0) {
                                console.println("Ошибка: id должен быть положительным числом");
                                continue;
                            }
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число для id");
                            continue;
                        }
                        try {
                            HumanBeingAsker asker = new HumanBeingAsker(console);
                            HumanBeing humanBeing = asker.askHumanBeing();
                            humanBeing.setId(id);
                            argument = humanBeing;
                        } catch (Exception e) {
                            console.println("Ошибка при создании объекта: " + e.getMessage());
                            continue;
                        }
                    } else if (commandName.equals("filter_starts_with_name")) {
                        console.println("Введите имя (не пустое):");
                        String name = console.read().trim();
                        if (name.isEmpty()) {
                            console.println("Ошибка: имя не может быть пустым");
                            continue;
                        }
                        HumanBeing humanBeing = new HumanBeing();
                        humanBeing.setName(name);
                        argument = humanBeing;
                    } else if (commandName.equals("count_less_than_impact_speed")) {
                        console.println("Введите impactSpeed (целое число):");
                        String impactSpeedInput = console.read().trim();
                        try {
                            long impactSpeed = Long.parseLong(impactSpeedInput);
                            HumanBeing humanBeing = new HumanBeing();
                            humanBeing.setImpactSpeed(impactSpeed);
                            argument = humanBeing;
                        } catch (NumberFormatException e) {
                            console.println("Ошибка: введите корректное целое число");
                            continue;
                        }
                    }
                }

                output.writeObject(commandName);
                output.writeObject(argument);
                output.writeObject(userId);
                output.flush();

                ExecutionResponse response = (ExecutionResponse) input.readObject();
                console.println("Ответ сервера: " + response.getMessage());

                if (commandName.equals("execute_script")) {
                    if (response.isSuccess()) {
                        console.println("Результат выполнения скрипта:");
                        String message = response.getMessage();
                        if (message != null && !message.isEmpty()) {
                            String[] lines = message.split("\\r?\\n");
                            for (String line : lines) {
                                console.println(line);
                            }
                        } else {
                            console.println("Пустой результат от сервера");
                        }
                    } else {
                        console.println("Ошибка выполнения скрипта: " + response.getMessage());
                    }
                }

                if ((commandName.equals("login") || commandName.equals("register")) && response.isSuccess()) {
                    try {
                        userId = Integer.parseInt(response.getMessage());
                    } catch (NumberFormatException e) {
                        console.println("Ошибка: некорректный userId от сервера");
                    }
                }
            }
        } catch (IOException | ClassNotFoundException e) {
            console.println("Ошибка клиента: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
package main.gui;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Scene;
import javafx.stage.Stage;
import main.gui.controllers.MainWindowController;

import java.util.Locale;
import java.util.ResourceBundle;

public class MainApp extends Application {
    private static Locale locale = new Locale("ru", "RU");
    private static ResourceBundle bundle = ResourceBundle.getBundle("main.gui.locale.messages", locale);

    public static Locale getLocale() { return locale; }
    public static void setLocale(Locale l) {
        locale = l;
        bundle = ResourceBundle.getBundle("main.gui.locale.messages", locale);
    }
    public static ResourceBundle getBundle() { return bundle; }

    @Override
    public void start(Stage primaryStage) throws Exception {
        showAuthWindow();
    }

    public static void showAuthWindow() throws Exception {
        FXMLLoader loader = new FXMLLoader(MainApp.class.getResource("/main/gui/views/auth.fxml"), getBundle());
        Stage stage = new Stage();
        stage.setTitle(bundle.getString("auth.title"));
        stage.setScene(new Scene(loader.load()));
        stage.show();
    }

    public static void showMainWindow(NetworkClient client, Integer userId) throws Exception {
        FXMLLoader loader = new FXMLLoader(MainApp.class.getResource("/main/gui/views/main.fxml"), getBundle());
        Stage stage = new Stage();
        stage.setTitle(bundle.getString("main.title"));
        stage.setScene(new Scene(loader.load()));
        MainWindowController controller = loader.getController();
        controller.initSession(client, userId);
        stage.show();
    }
}
package main.gui;

import utility.ExecutionResponse;

import java.io.*;
import java.net.Socket;

public class NetworkClient implements Closeable {
    private Socket socket;
    private ObjectOutputStream output;
    private ObjectInputStream input;

    public boolean connect(String host, int port) {
        try {
            socket = new Socket(host, port);
            output = new ObjectOutputStream(socket.getOutputStream());
            input = new ObjectInputStream(socket.getInputStream());
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    public ExecutionResponse sendCommand(String command, Object argument, Integer userId) {
        try {
            output.writeObject(command);
            output.writeObject(argument);
            output.writeObject(userId);
            output.flush();
            return (ExecutionResponse) input.readObject();
        } catch (Exception e) {
            return new ExecutionResponse(false, "Ошибка клиента: " + e.getMessage());
        }
    }

    @Override
    public void close() throws IOException {
        if (output != null) output.close();
        if (input != null) input.close();
        if (socket != null) socket.close();
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.NetworkClient;
import models.HumanBeing;
import models.WeaponType;
import utility.ExecutionResponse;

public class AddHumanController {
    @FXML private TextField nameField;
    @FXML private TextField coordinateXField;
    @FXML private TextField coordinateYField;
    @FXML private TextField impactSpeedField;
    @FXML private CheckBox realHeroCheckBox;
    @FXML private CheckBox hasToothpickCheckBox;
    @FXML private ComboBox<WeaponType> weaponTypeComboBox;
    @FXML private ComboBox<String> moodComboBox;
    @FXML private TextField carNameField;
    @FXML private Button saveButton;
    @FXML private Label errorLabel;

    private NetworkClient networkClient;
    private Integer userId;
    private String lang;
    private Runnable reloadCallback;

    public void init(NetworkClient networkClient, Integer userId, String lang, Runnable reloadCallback) {
        this.networkClient = networkClient;
        this.userId = userId;
        this.lang = lang;
        this.reloadCallback = reloadCallback;
    }

    @FXML
    private void initialize() {
        weaponTypeComboBox.getItems().setAll(WeaponType.values());
        moodComboBox.getItems().setAll("SADNESS", "LONGING", "GLOOM", "CALM");

        saveButton.setOnAction(event -> handleSave());
    }

    private void handleSave() {
        errorLabel.setText("");
        String name = nameField.getText().trim();
        String xText = coordinateXField.getText().trim();
        String yText = coordinateYField.getText().trim();
        String impactSpeedText = impactSpeedField.getText().trim();
        String carName = carNameField.getText().trim();

        if (name.isEmpty()) {
            errorLabel.setText("Имя не может быть пустым.");
            return;
        }
        double x;
        float y;
        long impactSpeed;
        try {
            x = Double.parseDouble(xText);
        } catch (NumberFormatException e) {
            errorLabel.setText("Координата X должна быть числом.");
            return;
        }
        try {
            y = Float.parseFloat(yText);
        } catch (NumberFormatException e) {
            errorLabel.setText("Координата Y должна быть числом.");
            return;
        }
        try {
            impactSpeed = Long.parseLong(impactSpeedText);
        } catch (NumberFormatException e) {
            errorLabel.setText("Impact Speed должен быть числом.");
            return;
        }

        Boolean hasToothpick = null;
        if (hasToothpickCheckBox.isIndeterminate()) {
            hasToothpick = null;
        } else {
            hasToothpick = hasToothpickCheckBox.isSelected();
        }

        WeaponType weaponType = weaponTypeComboBox.getValue();
        if (weaponType == null) {
            errorLabel.setText("Weapon Type не выбран.");
            return;
        }

        String mood = moodComboBox.getValue();
        if (mood == null) {
            errorLabel.setText("Mood не выбран.");
            return;
        }

        if (carName.isEmpty()) {
            errorLabel.setText("Car Name не может быть пустым.");
            return;
        }

        HumanBeing human = new HumanBeing();
        human.setName(name);
        human.setCoordinates(new models.Coordinates(x, y));
        human.setImpactSpeed(impactSpeed);
        human.setRealHero(realHeroCheckBox.isSelected());
        human.setHasToothpick(hasToothpick);
        human.setWeaponType(weaponType);
        human.setMood(mood);
        human.setCar(new models.Car(carName));

        ExecutionResponse response = networkClient.sendCommand("add", human, userId);
        if (response.isSuccess()) {
            Stage stage = (Stage) saveButton.getScene().getWindow();
            stage.close();
            if (reloadCallback != null) reloadCallback.run();
        } else {
            errorLabel.setText(response.getMessage());
        }
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.MainApp;
import main.gui.NetworkClient;
import models.Car;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.IOException;
import java.util.Locale;

public class AuthController {
    @FXML private TextField usernameField;
    @FXML private PasswordField passwordField;
    @FXML private Button loginButton;
    @FXML private Button registerButton;
    @FXML private ComboBox<String> languageBox;
    @FXML private Label messageLabel;

    private NetworkClient networkClient;
    private Integer userId;

    private int lastLanguageIndex = -1;

    @FXML
    private void initialize() {
        languageBox.getItems().setAll("Русский", "Македонский", "Latviešu", "Español (Colombia)");
        Locale current = MainApp.getLocale();
        int idx = 0;
        if (current.getLanguage().equals("ru")) idx = 0;
        else if (current.getLanguage().equals("mk")) idx = 1;
        else if (current.getLanguage().equals("lv")) idx = 2;
        else if (current.getLanguage().equals("es")) idx = 3;
        languageBox.getSelectionModel().select(idx);
        lastLanguageIndex = idx;

        languageBox.getSelectionModel().selectedIndexProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            if (newVal.intValue() == lastLanguageIndex) return;
            lastLanguageIndex = newVal.intValue();
            switch (newVal.intValue()) {
                case 0:
                    MainApp.setLocale(new Locale("ru", "RU")); break;
                case 1:
                    MainApp.setLocale(new Locale("mk", "MK")); break;
                case 2:
                    MainApp.setLocale(new Locale("lv", "LV")); break;
                case 3:
                    MainApp.setLocale(new Locale("es", "CO")); break;
            }
            java.util.ResourceBundle.clearCache();
            reload();
        });
    }

    private void reload() {
        try {
            Stage stage = (Stage) usernameField.getScene().getWindow();
            stage.close();
            MainApp.showAuthWindow();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @FXML
    private void handleLogin(javafx.event.ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.empty"));
            return;
        }

        if (networkClient != null) {
            try { networkClient.close(); } catch (IOException ignored) {}
        }
        networkClient = new NetworkClient();
        if (!networkClient.connect("localhost", 5000)) {
            messageLabel.setText("Ошибка соединения с сервером");
            return;
        }
        HumanBeing user = new HumanBeing();
        user.setName(username);
        user.setCar(new Car(password));
        ExecutionResponse response = networkClient.sendCommand("login", user, null);
        if (response.isSuccess()) {
            try {
                userId = Integer.parseInt(response.getMessage());
                messageLabel.setText(MainApp.getBundle().getString("auth.login.success"));
                try {
                    MainApp.showMainWindow(networkClient, userId);
                    Stage stage = (Stage) loginButton.getScene().getWindow();
                    stage.close();
                } catch (Exception e) {
                    e.printStackTrace();
                    messageLabel.setText("Ошибка открытия главного окна: " + e.getMessage());
                }
            } catch (NumberFormatException e) {
                messageLabel.setText("Некорректный userId от сервера");
                try { networkClient.close(); } catch (IOException ignored) {}
            }
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.login.fail") + " " + response.getMessage());
            try { networkClient.close(); } catch (IOException ignored) {}
        }
    }

    @FXML
    private void handleRegister(javafx.event.ActionEvent event) {
        String username = usernameField.getText();
        String password = passwordField.getText();
        if (username.isEmpty() || password.isEmpty()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.empty"));
            return;
        }

        if (networkClient != null) {
            try { networkClient.close(); } catch (IOException ignored) {}
        }
        networkClient = new NetworkClient();
        if (!networkClient.connect("localhost", 5000)) {
            messageLabel.setText("Ошибка соединения с сервером");
            return;
        }
        HumanBeing user = new HumanBeing();
        user.setName(username);
        user.setCar(new Car(password));
        ExecutionResponse response = networkClient.sendCommand("register", user, null);
        if (response.isSuccess()) {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.success"));
        } else {
            messageLabel.setText(MainApp.getBundle().getString("auth.register.fail") + " " + response.getMessage());
            try { networkClient.close(); } catch (IOException ignored) {}
        }
    }

    public NetworkClient getNetworkClient() {
        return networkClient;
    }
    public Integer getUserId() {
        return userId;
    }
}
package main.gui.controllers;

import javafx.fxml.FXML;
import javafx.scene.control.*;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.input.MouseEvent;

public class MainController {
    @FXML private Label userLabel;
    @FXML private TableView<?> tableView;
    @FXML private Canvas canvas;

    @FXML
    private void initialize() {
        userLabel.setText("User: ...");
    }

    @FXML
    private void handleCanvasClick(MouseEvent event) {
        GraphicsContext gc = canvas.getGraphicsContext2D();
        // TODO: обработка клика, выделение объекта, вывод информации
    }

}
package main.gui.controllers;

import javafx.collections.FXCollections;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.stage.Stage;
import main.gui.MainApp;
import main.gui.NetworkClient;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import java.util.stream.Collectors;

public class MainWindowController {
    @FXML private ComboBox<String> languageBox;
    @FXML private ListView<String> commandListView;
    @FXML private Label commandTitle;
    @FXML private TextArea commandOutput;
    @FXML private Button executeButton;
    @FXML private TextField argumentField;
    @FXML private Button registerButton;
    @FXML private Button exitButton;

    private NetworkClient networkClient;
    private Integer userId;

    private final List<String> commands = Arrays.asList(
            "add", "update", "remove_head", "clear", "info", "show",
            "help", "filter_starts_with_name", "print_unique_impact_speed",
            "count_less_than_impact_speed", "execute_script", "removebyid"
    );

    private int lastLanguageIndex = -1;

    public void initSession(NetworkClient networkClient, Integer userId) {
        this.networkClient = networkClient;
        this.userId = userId;
        List<String> visibleCommands = commands.stream()
                .filter(cmd -> !cmd.equals("login") && !cmd.equals("register"))
                .collect(Collectors.toList());
        commandListView.setItems(FXCollections.observableArrayList(visibleCommands));
    }

    @FXML
    private void initialize() {
        languageBox.getItems().setAll("Русский", "Македонский", "Latviešu", "Español (Colombia)");
        Locale current = MainApp.getLocale();
        int idx = 0;
        if (current.getLanguage().equals("ru")) idx = 0;
        else if (current.getLanguage().equals("mk")) idx = 1;
        else if (current.getLanguage().equals("lv")) idx = 2;
        else if (current.getLanguage().equals("es")) idx = 3;
        languageBox.getSelectionModel().select(idx);
        lastLanguageIndex = idx;

        languageBox.getSelectionModel().selectedIndexProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal == null) return;
            if (newVal.intValue() == lastLanguageIndex) return;
            lastLanguageIndex = newVal.intValue();
            switch (newVal.intValue()) {
                case 0:
                    MainApp.setLocale(new Locale("ru", "RU")); break;
                case 1:
                    MainApp.setLocale(new Locale("mk", "MK")); break;
                case 2:
                    MainApp.setLocale(new Locale("lv", "LV")); break;
                case 3:
                    MainApp.setLocale(new Locale("es", "CO")); break;
            }
            java.util.ResourceBundle.clearCache();
            reload();
        });

        commandListView.getSelectionModel().selectedItemProperty().addListener((obs, oldVal, newVal) -> {
            commandTitle.setText(newVal == null ? "" : newVal);
            commandOutput.clear();
            argumentField.clear();
        });
        commandListView.getSelectionModel().selectFirst();

        executeButton.setOnAction(event -> executeSelectedCommand());
        argumentField.setOnAction(event -> executeSelectedCommand());
        registerButton.setOnAction(event -> goToRegister());
        exitButton.setOnAction(event -> exitApp());
    }

    private void executeSelectedCommand() {
        String command = commandListView.getSelectionModel().getSelectedItem();
        if (command == null) return;
        String arg = argumentField.getText().trim();
        Object argument = null;

        try {
            switch (command) {
                case "add":
                    openAddHumanDialog(null);
                    return;
                case "update":
                    if (arg.isEmpty()) {
                        commandOutput.setText("Ошибка: необходимо указать id для обновления.");
                        return;
                    }
                    try {
                        Long id = Long.parseLong(arg);
                        ExecutionResponse getResp = networkClient.sendCommand("get_by_id", id, userId);
                        if (!getResp.isSuccess() || getResp.getHumanBeing() == null) {
                            commandOutput.setText("Элемент не найден или не принадлежит вам.");
                            return;
                        }
                        openAddHumanDialog(getResp.getHumanBeing());
                    } catch (NumberFormatException e) {
                        commandOutput.setText("Ошибка: id должен быть числом.");
                    }
                    return;
                case "removebyid":
                    if (arg.isEmpty()) {
                        commandOutput.setText("Ошибка: необходимо указать id.");
                        return;
                    }
                    try {
                        Long id = Long.parseLong(arg);
                        HumanBeing removeHuman = new HumanBeing();
                        removeHuman.setId(id);
                        argument = removeHuman;
                    } catch (NumberFormatException e) {
                        commandOutput.setText("Ошибка: id должен быть числом.");
                        return;
                    }
                    break;
                case "count_less_than_impact_speed":
                    if (arg.isEmpty()) {
                        commandOutput.setText("Ошибка: необходимо указать значение impactSpeed.");
                        return;
                    }
                    try {
                        long impactSpeed = Long.parseLong(arg);
                        HumanBeing countHuman = new HumanBeing();
                        countHuman.setImpactSpeed(impactSpeed);
                        argument = countHuman;
                    } catch (NumberFormatException e) {
                        commandOutput.setText("Ошибка: impactSpeed должен быть числом.");
                        return;
                    }
                    break;
                case "filter_starts_with_name":
                    if (arg.isEmpty()) {
                        commandOutput.setText("Ошибка: необходимо указать подстроку для поля name.");
                        return;
                    }
                    HumanBeing filterHuman = new HumanBeing();
                    filterHuman.setName(arg);
                    argument = filterHuman;
                    break;
                case "execute_script":
                    if (arg.isEmpty()) {
                        commandOutput.setText("Ошибка: требуется путь к файлу скрипта.");
                        return;
                    }
                    HumanBeing scriptHuman = new HumanBeing();
                    scriptHuman.setName(arg);
                    argument = scriptHuman;
                    break;
                default:
                    argument = null;
            }
        } catch (Exception e) {
            commandOutput.setText("Ошибка: " + e.getMessage());
            return;
        }

        if (command.equals("help") || command.equals("info") || command.equals("show") || command.equals("clear")) {
            String currentLang = MainApp.getLocale().getLanguage();
            HumanBeing langArg = new HumanBeing();
            langArg.setName(currentLang);
            ExecutionResponse response = networkClient.sendCommand(command, langArg, userId);

            if ("help".equals(command)) {
                String filtered = Arrays.stream(response.getMessage().split("\\r?\\n"))
                        .filter(line -> !line.trim().startsWith("login") && !line.trim().startsWith("register"))
                        .collect(Collectors.joining("\n"));
                commandOutput.setText(filtered);
            } else {
                commandOutput.setText(response.getMessage());
            }
        } else {
            ExecutionResponse response = networkClient.sendCommand(command, argument, userId);
            commandOutput.setText(response.getMessage());
        }
    }

    private void openAddHumanDialog(HumanBeing humanBeing) {
        try {
            FXMLLoader loader = new FXMLLoader(getClass().getResource("/main/gui/views/add_human.fxml"));
            Parent root = loader.load();
            AddHumanController controller = loader.getController();
            controller.init(networkClient, userId, MainApp.getLocale().getLanguage(), this::reload);

            Stage stage = new Stage();
            stage.setTitle("Добавить HumanBeing");
            stage.setScene(new Scene(root));
            stage.initOwner(executeButton.getScene().getWindow());
            stage.showAndWait();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void goToRegister() {
        try {
            if (networkClient != null) {
                networkClient.close();
            }
        } catch (IOException ignored) {}
        try {
            Stage stage = (Stage) registerButton.getScene().getWindow();
            stage.close();
            MainApp.showAuthWindow();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private void exitApp() {
        try {
            networkClient.sendCommand("exit", null, userId);
            networkClient.close();
        } catch (IOException ignored) {}
        Stage stage = (Stage) exitButton.getScene().getWindow();
        stage.close();
    }

    private void reload() {
        try {
            Stage stage = (Stage) languageBox.getScene().getWindow();
            NetworkClient oldClient = this.networkClient;
            Integer oldUserId = this.userId;
            stage.close();
            MainApp.showMainWindow(oldClient, oldUserId);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return "HumanBeing{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", coordinates=" + coordinates +
                ", creationDate=" + creationDate +
                ", realHero=" + realHero +
                ", hasToothpick=" + hasToothpick +
                ", impactSpeed=" + impactSpeed +
                ", weaponType=" + weaponType +
                ", mood=" + mood +
                ", car=" + car +
                ", userId=" + userId +
                '}';
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;
import models.HumanBeing;

public class ExecutionResponse implements Serializable {
    private boolean success;
    private String message;
    private HumanBeing humanBeing;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
        this.humanBeing = null;
    }

    public ExecutionResponse(boolean success, String message, HumanBeing humanBeing) {
        this.success = success;
        this.message = message;
        this.humanBeing = humanBeing;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }

    public HumanBeing getHumanBeing() {
        return humanBeing;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        humanBeing.setCoordinates(new Coordinates(x, y));

        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood mood = Mood.valueOf(moodInput.toUpperCase());
                humanBeing.setMood(mood.toString());
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;

public class Request implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.time.LocalDateTime;
import java.util.Locale;
import java.util.ResourceBundle;

public class Add extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Add(Console console, CollectionManager collectionManager) {
        super("add", "добавить новый элемент в коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().isEmpty())
            lang = argument.getName();
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("add.error.not_authorized"));
        }

        if (argument == null) {
            return new ExecutionResponse(false, bundle.getString("add.error.no_argument"));
        }

        argument.setUserId(userId);
        argument.setCreationDate(LocalDateTime.now());
        collectionManager.add(argument, userId); // <-- так правильно

        return new ExecutionResponse(true, bundle.getString("add.success"));
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.Locale;
import java.util.ResourceBundle;

public class Clear extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Clear(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("clear", "очистить коллекцию");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: clear, userId: " + userId);

        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("clear.error.not_authorized"));
        }

        boolean success = collectionManager.clear(userId);
        if (success) {
            return new ExecutionResponse(true, bundle.getString("clear.success") + " " + userId);
        } else {
            return new ExecutionResponse(false, bundle.getString("clear.error.failed"));
        }
    }
}
package commands;

import models.HumanBeing;
import utility.ExecutionResponse;

public abstract class Command {
    protected String name;
    protected String description;

    public Command(String name, String description) {
        this.name = name;
        this.description = description;
    }

    public abstract ExecutionResponse execute(HumanBeing argument, Integer userId);

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class CountLessThanImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public CountLessThanImpactSpeed(Console console, CollectionManager collectionManager) {
        super("count_less_than_impact_speed", "вывести количество элементов, значение поля impactSpeed которых меньше заданного");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: count_less_than_impact_speed, userId: " + userId);
        if (argument == null || argument.getImpactSpeed() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать значение impactSpeed");
        }

        long threshold = argument.getImpactSpeed();
        long count = collectionManager.getCollection().stream()
                .filter(h -> h.getUserId().equals(userId))
                .filter(h -> h.getImpactSpeed() < threshold)
                .count();

        return new ExecutionResponse(true, "Количество элементов с impactSpeed меньше " + threshold + ": " + count);
    }
}
package commands;

import models.HumanBeing;
import models.Coordinates;
import models.Car;
import models.WeaponType;
import models.Mood;
import utility.Console;
import utility.ExecutionResponse;
import managers.CommandManager;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.util.*;

public class ExecuteScript extends Command {
    private final Console console;
    private final CommandManager commandManager;
    private final Set<String> executedFiles = new HashSet<>();
    private final List<String> inputLines = new ArrayList<>();

    public ExecuteScript(Console console, CommandManager commandManager) {
        super("execute_script", "исполнить скрипт из файла");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || humanBeing.getName() == null || humanBeing.getName().trim().isEmpty()) {
            return new ExecutionResponse(false, "Требуется путь к файлу скрипта");
        }

        String scriptPath = humanBeing.getName().trim();

        try {
            String absolutePath = Paths.get(scriptPath).toAbsolutePath().toString();

            if (executedFiles.contains(absolutePath)) {
                return new ExecutionResponse(false, "Обнаружена рекурсия: файл " + scriptPath + " уже выполняется");
            }

            executedFiles.add(absolutePath);
            StringBuilder scriptOutput = new StringBuilder();

            try (BufferedReader reader = new BufferedReader(new FileReader(absolutePath))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith("#")) continue;

                    String[] parts = line.split("\\s+", 2);
                    String commandName = parts[0].toLowerCase();
                    HumanBeing commandHumanBeing = new HumanBeing();

                    if (commandName.equals("execute_script")) {
                        commandHumanBeing.setName(parts.length > 1 ? parts[1] : "");
                    } else if (commandName.equals("add") || commandName.equals("update")) {
                        // Читаем следующие 9 строк для команды add/update
                        inputLines.clear();
                        for (int i = 0; i < 9; i++) {
                            String nextLine = reader.readLine();
                            if (nextLine == null) {
                                return new ExecutionResponse(false, "Неожиданный конец файла при чтении параметров команды " + commandName);
                            }
                            nextLine = nextLine.trim();
                            if (nextLine.isEmpty()) {
                                i--; // Пропускаем пустые строки
                                continue;
                            }
                            inputLines.add(nextLine);
                        }
                        // Устанавливаем параметры в объект HumanBeing в правильном порядке
                        if (inputLines.size() >= 1) commandHumanBeing.setName(inputLines.get(0));
                        if (inputLines.size() >= 3) {
                            try {
                                double x = Double.parseDouble(inputLines.get(1));
                                float y = Float.parseFloat(inputLines.get(2));
                                commandHumanBeing.setCoordinates(new Coordinates(x, y));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении координат: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 4) commandHumanBeing.setRealHero(Boolean.parseBoolean(inputLines.get(3)));
                        if (inputLines.size() >= 5) commandHumanBeing.setHasToothpick(Boolean.parseBoolean(inputLines.get(4)));
                        if (inputLines.size() >= 6) {
                            try {
                                commandHumanBeing.setImpactSpeed(Long.parseLong(inputLines.get(5)));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении impactSpeed: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 7) {
                            try {
                                commandHumanBeing.setWeaponType(WeaponType.valueOf(inputLines.get(6)));
                            } catch (IllegalArgumentException e) {
                                return new ExecutionResponse(false, "Ошибка при чтении weaponType: " + e.getMessage());
                            }
                        }
                        if (inputLines.size() >= 8) commandHumanBeing.setMood(inputLines.get(7));
                        if (inputLines.size() >= 9) {
                            String carName = inputLines.get(8);
                            commandHumanBeing.setCar(new Car(carName));
                        }
                        // Устанавливаем дату создания для команды add
                        if (commandName.equals("add")) {
                            commandHumanBeing.setCreationDate(LocalDateTime.now());
                        }
                    } else if (commandName.equals("removebyid")) {
                        if (parts.length > 1) {
                            try {
                                commandHumanBeing.setId(Long.parseLong(parts[1]));
                            } catch (NumberFormatException e) {
                                return new ExecutionResponse(false, "Ошибка: ID должен быть числом");
                            }
                        }
                    } else if (parts.length > 1) {
                        commandHumanBeing.setName(parts[1]);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, commandHumanBeing, userId);
                    scriptOutput.append(response.getMessage()).append("\n");
                }
            } finally {
                executedFiles.remove(absolutePath);
            }

            return new ExecutionResponse(true, scriptOutput.toString().trim());
        } catch (IOException e) {
            return new ExecutionResponse(false, "Ошибка при чтении файла: " + e.getMessage());
        }
    }
}
package commands;

import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Exit extends Command {
    private final Console console;

    public Exit(Console console) {
        super("exit", "завершить работу клиента");
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Завершение работы клиента");
        return new ExecutionResponse(true, "Клиент отключен");
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class FilterStartsWithName extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public FilterStartsWithName(Console console, CollectionManager collectionManager) {
        super("filter_starts_with_name", "вывести элементы, значение поля name которых начинается с заданной подстроки");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: filter_starts_with_name, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }
        if (argument == null || argument.getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать подстроку для поля name");
        }

        String prefix = argument.getName();
        console.println("Ищем элементы с именем, начинающимся с: " + prefix);
        
        StringBuilder response = new StringBuilder("Элементы с именем, начинающимся с \"" + prefix + "\":\n");
        boolean found = false;
        int totalElements = 0;
        int matchingElements = 0;

        for (HumanBeing human : collectionManager.getCollection()) {
            totalElements++;
            console.println("Проверяем элемент: " + human.getName() + " (userId: " + human.getUserId() + ")");
            if (human.getName().startsWith(prefix) && human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                matchingElements++;
            }
        }

        console.println("Всего элементов в коллекции: " + totalElements);
        console.println("Найдено совпадающих элементов: " + matchingElements);

        if (!found) {
            response.append("Элементы не найдены.");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CommandManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.Locale;
import java.util.ResourceBundle;

public class Help extends Command {
    private final Console console;
    private final CommandManager commandManager;

    public Help(Console console, CommandManager commandManager) {
        super("help", "вывести справку по доступным командам");
        this.console = console;
        this.commandManager = commandManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        Locale locale = new Locale(lang);

        ResourceBundle bundle; // <-- объявляем тут!ф
        try {
            bundle = ResourceBundle.getBundle("messages", locale);
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        StringBuilder response = new StringBuilder(
                bundle.containsKey("help.title")
                        ? bundle.getString("help.title") + "\n"
                        : "Доступные команды:\n"
        );

        for (var entry : commandManager.getCommands().entrySet()) {
            String name = entry.getKey();
            Command command = entry.getValue();
            String key = "help." + name;
            String description = bundle.containsKey(key)
                    ? bundle.getString(key)
                    : command.getDescription();
            response.append(name).append(": ").append(description).append("\n");
        }
        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;

public class Info extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Info(Console console, CollectionManager collectionManager) {
        super("info", "вывести информацию о коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: info, userId: " + userId);

        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("info.error.not_authorized"));
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        int totalElements = collection.size();
        int userElements = 0;
        for (HumanBeing human : collection) {
            if (human.getUserId().equals(userId)) userElements++;
        }

        StringBuilder response = new StringBuilder();
        response.append(bundle.getString("info.type")).append(" ").append(collection.getClass().getSimpleName()).append("\n");
        response.append(bundle.getString("info.init_date")).append(" ").append(collectionManager.getInitializationDate()).append("\n");
        response.append(bundle.getString("info.total_elements")).append(" ").append(totalElements).append("\n");
        response.append(bundle.getString("info.user_elements")).append(" ").append(userElements);

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Login extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Login(DatabaseManager dbManager, Console console) {
        super("login", "авторизоваться с существующим пользователем");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: login, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: " + "необходимо указать имя пользователя и пароль");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка авторизации: username=" + username);
        Integer resultId = dbManager.loginUser(username, password);
        if (resultId != null) {
            return new ExecutionResponse(true, String.valueOf(resultId));
        } else {
            return new ExecutionResponse(false, "Ошибка авторизации: неверный username или password");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashSet;
import java.util.Set;

public class PrintUniqueImpactSpeed extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public PrintUniqueImpactSpeed(Console console, CollectionManager collectionManager) {
        super("print_unique_impact_speed", "вывести уникальные значения поля impactSpeed");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: print_unique_impact_speed, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо авторизоваться (login) или зарегистрироваться (register)");
        }

        Set<Long> uniqueSpeeds = new HashSet<>();
        for (HumanBeing human : collectionManager.getCollection()) {
            if (human.getUserId().equals(userId)) {
                uniqueSpeeds.add(human.getImpactSpeed());
            }
        }

        if (uniqueSpeeds.isEmpty()) {
            return new ExecutionResponse(true, "У вас нет элементов в коллекции.");
        }

        StringBuilder response = new StringBuilder("Уникальные значения impactSpeed:\n");
        for (Long speed : uniqueSpeeds) {
            response.append(speed).append("\n");
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Register extends Command {
    private final DatabaseManager dbManager;
    private final Console console;

    public Register(DatabaseManager dbManager, Console console) {
        super("register", "зарегистрировать нового пользователя");
        this.dbManager = dbManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing user, Integer userId) {
        console.println("Выполняется команда: register, userId: " + userId);
        if (user == null || user.getName() == null || user.getCar() == null || user.getCar().getName() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать username и password");
        }

        String username = user.getName();
        String password = user.getCar().getName();
        console.println("Попытка регистрации: username=" + username);

        Integer newUserId = dbManager.registerUser(username, password);
        if (newUserId != null) {
            return new ExecutionResponse(true, String.valueOf(newUserId));
        } else {
            return new ExecutionResponse(false, "Ошибка регистрации: пользователь уже существует или неверные данные");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class RemoveById extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public RemoveById(Console console, CollectionManager collectionManager) {
        super("removebyid", "удалить элемент из коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: removebyid, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }
        if (argument == null || argument.getId() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать id для удаления");
        }

        Long id = argument.getId();
        // Debug: Print collection contents
        console.println("Содержимое коллекции перед удалением id=" + id + ":");
        for (Long key : collectionManager.getCollectionMap().keySet()) {
            HumanBeing hb = collectionManager.getCollectionMap().get(key);
            console.println("id=" + hb.getId() + ", userId=" + hb.getUserId());
        }

        HumanBeing humanBeing = collectionManager.getCollectionMap().get(id);
        if (humanBeing == null) {
            console.println("Элемент с id " + id + " не найден в коллекции");
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " не существует в коллекции");
        }
        if (!humanBeing.getUserId().equals(userId)) {
            console.println("Элемент с id " + id + " принадлежит userId=" + humanBeing.getUserId());
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " принадлежит другому пользователю");
        }

        boolean success = collectionManager.remove(id, userId);
        if (success) {
            console.println("Элемент с id " + id + " успешно удален");
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно удален");
        } else {
            console.println("Ошибка удаления id=" + id + " из базы данных");
            return new ExecutionResponse(false, "Ошибка при удалении элемента с id " + id + ": не удалось удалить из базы данных");
        }
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.List;

public class RemoveHead extends Command {
    private final CollectionManager collectionManager;
    private final DatabaseManager databaseManager;
    private final Console console;

    public RemoveHead(CollectionManager collection, Console console, DatabaseManager databaseManager) {
        super("remove_head", "вывести и удалить первый элемент коллекции");
        this.collectionManager = collection;
        this.databaseManager = databaseManager;
        this.console = console;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: remove_head, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }

        List<HumanBeing> collection = collectionManager.getCollection();
        if (collection.isEmpty()) {
            return new ExecutionResponse(false, "Коллекция пуста");
        }

        HumanBeing head = collection.stream()
                .filter(h -> h.getUserId().equals(userId))
                .findFirst()
                .orElse(null);

        if (head == null) {
            return new ExecutionResponse(false, "Нет элементов, принадлежащих пользователю с ID " + userId);
        }

        boolean success = collectionManager.remove(head.getId(), userId);
        if (success) {
            return new ExecutionResponse(true, "Первый элемент: " + head.toString() + "\nЭлемент успешно удален");
        } else {
            return new ExecutionResponse(false, "Ошибка при удалении первого элемента");
        }
    }
}
package commands;

import managers.CollectionManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;
import java.util.List;
import java.util.Locale;
import java.util.ResourceBundle;

public class Show extends Command {
    private final Console console;
    private final CollectionManager collectionManager;

    public Show(Console console, CollectionManager collectionManager) {
        super("show", "вывести все элементы коллекции");
        this.console = console;
        this.collectionManager = collectionManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: show, userId: " + userId);

        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        ResourceBundle bundle;
        try {
            bundle = ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            bundle = ResourceBundle.getBundle("messages", new Locale("ru"));
        }

        if (userId == null) {
            return new ExecutionResponse(false, bundle.getString("show.error.not_authorized"));
        }

        StringBuilder response = new StringBuilder(bundle.getString("show.header") + "\n");
        List<HumanBeing> collection = collectionManager.getCollection();
        boolean found = false;
        int totalElements = 0;
        int userElements = 0;

        for (HumanBeing human : collection) {
            totalElements++;
            if (human.getUserId().equals(userId)) {
                response.append(human.toString()).append("\n");
                found = true;
                userElements++;
            }
        }

        console.println(bundle.getString("show.console.total") + totalElements);
        console.println(bundle.getString("show.console.user") + userElements);

        if (!found) {
            response.append(bundle.getString("show.no_elements"));
        }

        return new ExecutionResponse(true, response.toString());
    }
}
package commands;

import managers.CollectionManager;
import managers.DatabaseManager;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

public class Update extends Command {
    private final Console console;
    private final CollectionManager collectionManager;
    private final DatabaseManager dbManager;

    public Update(Console console, CollectionManager collectionManager, DatabaseManager dbManager) {
        super("update", "обновить элемент коллекции по его id");
        this.console = console;
        this.collectionManager = collectionManager;
        this.dbManager = dbManager;
    }

    @Override
    public ExecutionResponse execute(HumanBeing argument, Integer userId) {
        console.println("Выполняется команда: update, userId: " + userId);
        if (userId == null) {
            return new ExecutionResponse(false, "Ошибка: пользователь не авторизован");
        }
        if (argument == null || argument.getId() == null) {
            return new ExecutionResponse(false, "Ошибка: необходимо указать id для обновления");
        }

        Long id = argument.getId();
        console.println("Содержимое коллекции перед обновлением id=" + id + ":");
        for (Long key : collectionManager.getCollectionMap().keySet()) {
            HumanBeing hb = collectionManager.getCollectionMap().get(key);
            console.println("id=" + hb.getId() + ", userId=" + hb.getUserId());
        }

        HumanBeing oldHuman = collectionManager.getCollectionMap().get(id);
        if (oldHuman == null) {
            console.println("Элемент с id " + id + " не найден в коллекции");
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " не существует в коллекции");
        }
        if (!oldHuman.getUserId().equals(userId)) {
            console.println("Элемент с id " + id + " принадлежит userId=" + oldHuman.getUserId());
            return new ExecutionResponse(false, "Ошибка: элемент с id " + id + " принадлежит другому пользователю");
        }

        argument.setUserId(userId);
        argument.setCreationDate(oldHuman.getCreationDate());

        boolean success = collectionManager.update(id, argument, userId);
        if (success) {
            console.println("Элемент с id " + id + " успешно обновлен");
            return new ExecutionResponse(true, "Элемент с id " + id + " успешно обновлен");
        } else {
            console.println("Ошибка обновления id=" + id + " в базе данных");
            return new ExecutionResponse(false, "Ошибка при обновлении элемента с id " + id + ": не удалось обновить в базе данных");
        }
    }
}
package main;

import managers.CollectionManager;
import managers.CommandManager;
import managers.DatabaseManager;
import server.Server;
import utility.Console;
import utility.StandardConsole;

public class ServerMain {
    public static void main(String[] args) {
        Console console = new StandardConsole();
        DatabaseManager databaseManager = new DatabaseManager();
        CollectionManager collectionManager = new CollectionManager(databaseManager);
        CommandManager commandManager = new CommandManager(console, collectionManager, databaseManager);
        Server server = new Server(5000, commandManager);
        server.run();
    }
}
package managers;

import models.HumanBeing;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CollectionManager {
    private final Map<Long, HumanBeing> collection;
    private final DatabaseManager dbManager;
    private final LocalDateTime initializationDate;

    public CollectionManager(DatabaseManager dbManager) {
        this.collection = new ConcurrentHashMap<>();
        this.dbManager = dbManager;
        this.initializationDate = LocalDateTime.now();
    }

    public List<HumanBeing> getCollection() {
        return dbManager.loadHumanBeings();
    }

    public LocalDateTime getInitializationDate() {
        return initializationDate;
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        if (humanBeing == null || userId == null) {
            return false;
        }
        if (dbManager.add(humanBeing, userId)) {
            collection.put(humanBeing.getId(), humanBeing);
            return true;
        }
        return false;
    }

    public boolean update(Long id, HumanBeing humanBeing, Integer userId) {
        return dbManager.updateHumanBeing(id, humanBeing, userId);
    }

    public boolean remove(Long id, Integer userId) {
        return dbManager.removeHumanBeing(id, userId);
    }

    public boolean clear(Integer userId) {
        return dbManager.clearHumanBeings(userId);
    }

    public Map<Long, HumanBeing> getCollectionMap() {
        return collection;
    }
}
package managers;

import commands.*;
import models.HumanBeing;
import utility.Console;
import utility.ExecutionResponse;

import java.util.HashMap;
import java.util.Map;

public class CommandManager {
    private final Map<String, Command> commands = new HashMap<>();
    private final Console console;

    public CommandManager(Console console, CollectionManager collectionManager, DatabaseManager databaseManager) {
        this.console = console;
        commands.put("add", new Add(console, collectionManager));
        commands.put("update", new Update(console, collectionManager, databaseManager));
        commands.put("remove_head", new RemoveHead(collectionManager, console, databaseManager));
        commands.put("clear", new Clear(console, collectionManager, databaseManager));
        commands.put("info", new Info(console, collectionManager));
        commands.put("show", new Show(console, collectionManager));
        commands.put("login", new Login(databaseManager, console));
        commands.put("register", new Register(databaseManager, console));
        commands.put("exit", new Exit(console));
        commands.put("help", new Help(console, this));
        commands.put("filter_starts_with_name", new FilterStartsWithName(console, collectionManager));
        commands.put("print_unique_impact_speed", new PrintUniqueImpactSpeed(console, collectionManager));
        commands.put("count_less_than_impact_speed", new CountLessThanImpactSpeed(console, collectionManager));
        commands.put("execute_script", new ExecuteScript(console, this));
        commands.put("removebyid", new RemoveById(console, collectionManager));
    }

    public ExecutionResponse executeCommand(String commandName, HumanBeing humanBeing, Integer userId) {
        Command command = commands.get(commandName);
        if (command == null) {
            return new ExecutionResponse(false, "Команда '" + commandName + "' не найдена. Введите 'help' для списка команд.");
        }
        return command.execute(humanBeing, userId);
    }

    public Map<String, Command> getCommands() {
        return commands;
    }
}
package managers;

import models.*;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class DatabaseManager {
    private final String url = "jdbc:postgresql://localhost:5432/studs";
    private final String user = "s434931";
    private final String password = "250806";
    private Connection connection;
    private final Map<Long, HumanBeing> collection;

    public DatabaseManager() {
        this.collection = new ConcurrentHashMap<>();
        connect();
        loadHumanBeings();
    }

    private void connect() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
            }
            connection = DriverManager.getConnection(url, user, password);
            System.out.println("Подключение к базе данных установлено: " + url);
        } catch (SQLException e) {
            System.err.println("Ошибка подключения к базе данных: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public void close() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                System.out.println("Соединение с базой данных закрыто");
            }
        } catch (SQLException e) {
            System.err.println("Ошибка при закрытии соединения с базой данных: " + e.getMessage());
        }
    }

    public Map<Long, HumanBeing> getCollection() {
        return collection;
    }

    public List<HumanBeing> loadHumanBeings() {
        collection.clear();
        List<HumanBeing> humans = new ArrayList<>();
        String query = "SELECT * FROM human_beings";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(query)) {
            while (rs.next()) {
                HumanBeing human = new HumanBeing();
                human.setId(rs.getLong("id"));
                human.setName(rs.getString("name"));
                human.setCoordinates(new Coordinates(
                        rs.getDouble("coordinate_x"),
                        rs.getFloat("coordinate_y")
                ));
                human.setCreationDate(rs.getTimestamp("creation_date").toLocalDateTime());
                human.setRealHero(rs.getBoolean("real_hero"));
                human.setHasToothpick(rs.getObject("has_toothpick") != null ? rs.getBoolean("has_toothpick") : null);
                human.setImpactSpeed(rs.getLong("impact_speed"));
                human.setWeaponType(WeaponType.valueOf(rs.getString("weapon_type")));
                human.setMood(rs.getString("mood"));
                human.setCar(new Car(rs.getString("car_name")));
                human.setUserId(rs.getInt("user_id"));
                collection.put(human.getId(), human);
                humans.add(human);
            }
            System.out.println("Коллекция загружена из базы данных: " + collection.size() + " элементов");
            return humans;
        } catch (SQLException e) {
            System.err.println("Ошибка загрузки коллекции: " + e.getMessage());
            return humans;
        }
    }

    public boolean add(HumanBeing humanBeing, Integer userId) {
        String sql = "INSERT INTO human_beings (name, coordinate_x, coordinate_y, creation_date, impact_speed, real_hero, has_toothpick, weapon_type, mood, car_name, user_id) " +
                "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setInt(11, userId);

            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    long id = rs.getLong(1);
                    humanBeing.setId(id);
                    return true;
                }
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка при добавлении элемента: " + e.getMessage());
            return false;
        }
    }

    public boolean removeHumanBeing(Long id, Integer userId) {
        if (id == null || userId == null) return false;
        String query = "DELETE FROM human_beings WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setLong(1, id);
            pstmt.setInt(2, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.remove(id);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка удаления: " + e.getMessage());
            return false;
        }
    }

    public boolean updateHumanBeing(Long id, HumanBeing humanBeing, Integer userId) {
        if (id == null || humanBeing == null || userId == null) return false;
        String query = "UPDATE human_beings SET name = ?, coordinate_x = ?, coordinate_y = ?, creation_date = ?, impact_speed = ?, real_hero = ?, has_toothpick = ?, weapon_type = ?, mood = ?, car_name = ? WHERE id = ? AND user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, humanBeing.getName());
            pstmt.setDouble(2, humanBeing.getCoordinates().getX());
            pstmt.setFloat(3, humanBeing.getCoordinates().getY());
            pstmt.setTimestamp(4, Timestamp.valueOf(humanBeing.getCreationDate()));
            pstmt.setLong(5, humanBeing.getImpactSpeed());
            pstmt.setBoolean(6, humanBeing.getRealHero());
            if (humanBeing.getHasToothpick() != null) {
                pstmt.setBoolean(7, humanBeing.getHasToothpick());
            } else {
                pstmt.setNull(7, Types.BOOLEAN);
            }
            pstmt.setString(8, humanBeing.getWeaponType().toString());
            pstmt.setString(9, humanBeing.getMood().toString());
            pstmt.setString(10, humanBeing.getCar().getName());
            pstmt.setLong(11, id);
            pstmt.setInt(12, userId);

            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                humanBeing.setId(id);
                humanBeing.setUserId(userId);
                collection.put(id, humanBeing);
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка обновления: " + e.getMessage());
            return false;
        }
    }

    public boolean clearHumanBeings(Integer userId) {
        if (userId == null) return false;
        String query = "DELETE FROM human_beings WHERE user_id = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setInt(1, userId);
            int rowsAffected = pstmt.executeUpdate();
            if (rowsAffected > 0) {
                collection.entrySet().removeIf(entry -> entry.getValue().getUserId().equals(userId));
                return true;
            }
            return false;
        } catch (SQLException e) {
            System.err.println("Ошибка очистки: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }

    public Integer loginUser(String username, String password) {
        String query = "SELECT id, password FROM users WHERE username = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            pstmt.setString(1, username);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                String storedPassword = rs.getString("password");
                String hashedInputPassword = hashPassword(password);
                if (hashedInputPassword.equals(storedPassword)) {
                    return rs.getInt("id");
                }
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка авторизации: " + e.getMessage());
            return null;
        }
    }

    public Integer registerUser(String username, String password) {
        String query = "INSERT INTO users (username, password) VALUES (?, ?) RETURNING id";
        try (PreparedStatement pstmt = connection.prepareStatement(query)) {
            String hashedPassword = hashPassword(password);
            System.out.println("Debug - Registration:");
            System.out.println("Username: " + username);
            System.out.println("Password: " + password);
            System.out.println("Hashed password: " + hashedPassword);
            pstmt.setString(1, username);
            pstmt.setString(2, hashedPassword);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                return rs.getInt("id");
            }
            return null;
        } catch (SQLException e) {
            System.err.println("Ошибка регистрации: " + e.getMessage());
            return null;
        }
    }

    private String hashPassword(String password) {
        int hash = password.hashCode();
        hash = hash * 31 + "SALT".hashCode();
        hash = hash * 31 + password.length();
        return String.format("%d", hash);
    }
}
package models;

import java.io.Serializable;

public class Car implements Serializable {
    private static final long serialVersionUID = 1L;
    private String name; // Не может быть null

    public Car(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя машины не может быть null или пустым");
        }
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Car{name='" + name + "'}";
    }
}
package models;

import java.io.Serializable;

public class Coordinates implements Serializable {
    private static final long serialVersionUID = 1L;
    private double x;
    private float y;

    public Coordinates(double x, float y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public void setX(double x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return String.format("(x=%.2f, y=%.2f)", x, y);
    }
}
package models;

import java.io.Serializable;
import java.time.LocalDateTime;

public class HumanBeing implements Comparable<HumanBeing>, Serializable {
    private static final long serialVersionUID = 1L;
    private Long id; // Не может быть null, > 0, уникальное, генерируется автоматически
    private String name; // Не может быть null, не пустое
    private Coordinates coordinates; // Не может быть null
    private LocalDateTime creationDate; // Не может быть null, генерируется автоматически
    private boolean realHero;
    private Boolean hasToothpick; // Может быть null
    private Long impactSpeed;
    private WeaponType weaponType; // Не может быть null
    private String mood; // Не может быть null
    private Car car; // Не может быть null
    private Integer userId; // Для идентификации пользователя

    public HumanBeing() {
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        if (id == null || id <= 0) {
            throw new IllegalArgumentException("ID должен быть положительным числом");
        }
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        if (name == null || name.isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть null или пустым");
        }
        this.name = name;
    }

    public Coordinates getCoordinates() {
        return coordinates;
    }

    public void setCoordinates(Coordinates coordinates) {
        if (coordinates == null) {
            throw new IllegalArgumentException("Координаты не могут быть null");
        }
        this.coordinates = coordinates;
    }

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new IllegalArgumentException("Дата создания не может быть null");
        }
        this.creationDate = creationDate;
    }

    public boolean getRealHero() {
        return realHero;
    }

    public void setRealHero(boolean realHero) {
        this.realHero = realHero;
    }

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    public void setHasToothpick(Boolean hasToothpick) {
        this.hasToothpick = hasToothpick;
    }

    public Long getImpactSpeed() {
        return impactSpeed;
    }

    public void setImpactSpeed(Long impactSpeed) {
        this.impactSpeed = impactSpeed;
    }

    public WeaponType getWeaponType() {
        return weaponType;
    }

    public void setWeaponType(WeaponType weaponType) {
        if (weaponType == null) {
            throw new IllegalArgumentException("Тип оружия не может быть null");
        }
        this.weaponType = weaponType;
    }

    public String getMood() {
        return mood;
    }

    public void setMood(String mood) {
        if (mood == null) {
            throw new IllegalArgumentException("Настроение не может быть null");
        }
        this.mood = mood;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        if (car == null) {
            throw new IllegalArgumentException("Машина не может быть null");
        }
        this.car = car;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    @Override
    public int compareTo(HumanBeing other) {
        return Long.compare(this.impactSpeed != null ? this.impactSpeed : 0,
                other.impactSpeed != null ? other.impactSpeed : 0);
    }

    @Override
    public String toString() {
        return String.format("HumanBeing{id=%d, name='%s', coordinates=%s, creationDate=%s, realHero=%b, hasToothpick=%s, impactSpeed=%d, weaponType=%s, mood=%s, car=%s, userId=%d}",
                id, name, coordinates, creationDate, realHero, hasToothpick, impactSpeed, weaponType, mood, car, userId);
    }
}
package models;

import java.io.Serializable;

public enum Mood implements Serializable {
    SADNESS, LONGING, CALM, RAGE, FRENZY;

    private static final long serialVersionUID = 1L;
}
package models;

import java.io.Serializable;

public enum WeaponType implements Serializable {
    AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN;

    private static final long serialVersionUID = 1L;
}
package server;

import managers.CommandManager;
import models.HumanBeing;
import utility.ExecutionResponse;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    private final int port;
    private final CommandManager commandManager;

    public Server(int port, CommandManager commandManager) {
        this.port = port;
        this.commandManager = commandManager;
    }

    public void run() {
        try (ServerSocket serverSocket = new ServerSocket(port)) {
            System.out.println("Сервер запущен на порту " + port);
            while (true) {
                try (Socket clientSocket = serverSocket.accept()) {
                    System.out.println("Клиент подключен: " + clientSocket.getInetAddress());
                    handleClient(clientSocket);
                } catch (Exception e) {
                    System.out.println("Ошибка обработки клиента: " + e.getMessage());
                    e.printStackTrace();
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка сервера: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void handleClient(Socket clientSocket) throws IOException {
        try (ObjectInputStream input = new ObjectInputStream(clientSocket.getInputStream());
             ObjectOutputStream output = new ObjectOutputStream(clientSocket.getOutputStream())) {

            while (!clientSocket.isClosed()) {
                try {
                    String commandName = (String) input.readObject();
                    Object argument = input.readObject();
                    Integer userId = (Integer) input.readObject();

                    System.out.println("Получен запрос: command=" + commandName + ", userId=" + userId);
                    if (argument != null) {
                        if (argument instanceof HumanBeing) {
                            System.out.println("Аргумент: " + ((HumanBeing) argument).getName());
                        } else if (argument instanceof Long) {
                            System.out.println("Аргумент: id=" + argument);
                        } else {
                            System.out.println("Аргумент: " + argument);
                        }
                    } else {
                        System.out.println("Аргумент: null");
                    }

                    HumanBeing humanBeing = null;
                    if (argument instanceof HumanBeing) {
                        humanBeing = (HumanBeing) argument;
                    } else if (commandName.equals("removebyid") && argument instanceof Long) {
                        humanBeing = new HumanBeing();
                        humanBeing.setId((Long) argument);
                    }

                    ExecutionResponse response = commandManager.executeCommand(commandName, humanBeing, userId);

                    output.writeObject(response);
                    output.flush();

                    if (commandName.equals("exit")) {
                        System.out.println("Клиент отключен: " + clientSocket.getInetAddress());
                        break;
                    }
                } catch (ClassNotFoundException e) {
                    System.err.println("Ошибка чтения данных: " + e.getMessage());
                    output.writeObject(new ExecutionResponse(false, "Ошибка чтения данных: " + e.getMessage()));
                }
            }
        } catch (IOException e) {
            System.err.println("Ошибка обработки клиента: " + e.getMessage());
            throw e;
        }
    }
}
package utility;

public interface Console {
    void println(String message);
    String read(); // Assumed method instead of readLine()
}
package utility;

import java.io.Serializable;
import models.HumanBeing;

public class ExecutionResponse implements Serializable {
    private boolean success;
    private String message;
    private HumanBeing humanBeing;

    public ExecutionResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
        this.humanBeing = null;
    }

    public ExecutionResponse(boolean success, String message, HumanBeing humanBeing) {
        this.success = success;
        this.message = message;
        this.humanBeing = humanBeing;
    }

    public boolean isSuccess() {
        return success;
    }

    public String getMessage() {
        return message;
    }

    public HumanBeing getHumanBeing() {
        return humanBeing;
    }
}
package utility;

import models.*;

import java.io.Serializable;

public class HumanBeingAsker implements Serializable {
    private static final long serialVersionUID = 1L;
    private final Console console;

    public HumanBeingAsker(Console console) {
        this.console = console;
    }

    public HumanBeing askHumanBeing() {
        HumanBeing humanBeing = new HumanBeing();

        // Name
        while (true) {
            console.println("Введите имя (не пустое):");
            String name = console.read().trim();
            if (name == null || name.isEmpty()) {
                console.println("Ошибка: имя не может быть пустым");
                continue;
            }
            humanBeing.setName(name);
            break;
        }

        // Coordinate X
        double x = 0.0;
        while (true) {
            try {
                console.println("Введите координату x (дробное число, не больше " + Double.MAX_VALUE + "):");
                String xInput = console.read().trim();
                if (xInput.isEmpty()) {
                    console.println("Ошибка: координата x не может быть пустой");
                    continue;
                }
                x = Double.parseDouble(xInput);
                if (Double.isInfinite(x) || Double.isNaN(x)) {
                    console.println("Ошибка: координата x должна быть конечным числом");
                    continue;
                }
                if (Math.abs(x) > Double.MAX_VALUE) {
                    console.println("Ошибка: координата x превышает допустимый диапазон (±" + Double.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для x");
            }
        }

        // Coordinate Y
        float y = 0.0f;
        while (true) {
            try {
                console.println("Введите координату y (дробное число, не больше " + Float.MAX_VALUE + "):");
                String yInput = console.read().trim();
                if (yInput.isEmpty()) {
                    console.println("Ошибка: координата y не может быть пустой");
                    continue;
                }
                y = Float.parseFloat(yInput);
                if (Float.isInfinite(y) || Float.isNaN(y)) {
                    console.println("Ошибка: координата y должна быть конечным числом");
                    continue;
                }
                if (Math.abs(y) > Float.MAX_VALUE) {
                    console.println("Ошибка: координата y превышает допустимый диапазон (±" + Float.MAX_VALUE + ")");
                    continue;
                }
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное дробное число для y");
            }
        }

        // Устанавливаем координаты один раз после успешного ввода x и y
        humanBeing.setCoordinates(new Coordinates(x, y));

        // Real Hero
        while (true) {
            console.println("Введите realHero (true/false):");
            String realHeroInput = console.read().trim().toLowerCase();
            if (realHeroInput.equals("true") || realHeroInput.equals("false")) {
                humanBeing.setRealHero(Boolean.parseBoolean(realHeroInput));
                break;
            }
            console.println("Ошибка: введите true или false");
        }

        // Has Toothpick
        while (true) {
            console.println("Введите hasToothpick (true/false/null):");
            String hasToothpickInput = console.read().trim().toLowerCase();
            if (hasToothpickInput.equals("true") || hasToothpickInput.equals("false")) {
                humanBeing.setHasToothpick(Boolean.parseBoolean(hasToothpickInput));
                break;
            } else if (hasToothpickInput.equals("null")) {
                humanBeing.setHasToothpick(null);
                break;
            }
            console.println("Ошибка: введите true, false или null");
        }

        // Impact Speed
        while (true) {
            console.println("Введите impactSpeed (целое число):");
            String input = console.read().trim();
            if (input.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                long impactSpeed = Long.parseLong(input);
                humanBeing.setImpactSpeed(impactSpeed);
                break;
            } catch (NumberFormatException e) {
                console.println("Ошибка: введите корректное целое число");
            }
        }

        // Weapon Type
        while (true) {
            console.println("Введите weaponType (AXE/SHOTGUN/RIFLE/KNIFE/MACHINE_GUN):");
            String weaponInput = console.read().trim();
            if (weaponInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                humanBeing.setWeaponType(WeaponType.valueOf(weaponInput.toUpperCase()));
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите один из типов оружия: AXE, SHOTGUN, RIFLE, KNIFE, MACHINE_GUN");
            }
        }

        // Mood
        while (true) {
            console.println("Введите mood (SADNESS/LONGING/CALM/RAGE/FRENZY):");
            String moodInput = console.read().trim();
            if (moodInput.isEmpty()) {
                console.println("Ошибка: значение не может быть пустым");
                continue;
            }
            try {
                Mood.valueOf(moodInput.toUpperCase()); // Validate input
                humanBeing.setMood(moodInput);
                break;
            } catch (IllegalArgumentException e) {
                console.println("Ошибка: выберите одно из настроений: SADNESS, LONGING, CALM, RAGE, FRENZY");
            }
        }

        // Car
        while (true) {
            console.println("Введите car.name (не пустое):");
            String carName = console.read().trim();
            if (carName.isEmpty()) {
                console.println("Ошибка: имя машины не может быть пустым");
                continue;
            }
            humanBeing.setCar(new Car(carName));
            break;
        }

        // Creation Date (set automatically)
        humanBeing.setCreationDate(java.time.LocalDateTime.now());

        return humanBeing;
    }
}
package utility;

import models.HumanBeing;

import java.util.Locale;
import java.util.ResourceBundle;

public class LocalizationUtil {
    public static ResourceBundle getBundle(HumanBeing argument) {
        String lang = "ru";
        if (argument != null && argument.getName() != null && !argument.getName().trim().isEmpty()) {
            lang = argument.getName().trim();
        }
        try {
            return ResourceBundle.getBundle("messages", new Locale(lang));
        } catch (Exception e) {
            return ResourceBundle.getBundle("messages", new Locale("ru"));
        }
    }
}
package utility;

import models.HumanBeing;
import java.io.Serializable;

public class Request implements Serializable {
    private static final long serialVersionUID = 1L;
    private String commandName;
    private HumanBeing argument;
    private Integer userId;

    public Request(String commandName, HumanBeing argument, Integer userId) {
        this.commandName = commandName;
        this.argument = argument;
        this.userId = userId;
    }

    public String getCommandName() {
        return commandName;
    }

    public HumanBeing getArgument() {
        return argument;
    }

    public Integer getUserId() {
        return userId;
    }

    @Override
    public String toString() {
        return "Request{commandName='" + commandName + "', argument=" + argument + ", userId=" + userId + "}";
    }
}
package utility;

import java.util.Scanner;

public class StandardConsole implements Console {
    private final Scanner scanner = new Scanner(System.in);

    @Override
    public void println(String message) {
        System.out.println(message);
    }

    @Override
    public String read() {
        return scanner.nextLine();
    }
}
package utility;

public interface Validatable {
    boolean validate();
}
